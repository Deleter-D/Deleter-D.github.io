---
title: 算法练习——回溯
toc: true
mathjax: true
tags:
  - 算法
  - 回溯
  - 力扣
categories:
  - 算法
  - 力扣
abbrlink: 18443
date: 2024-03-22 19:19:38
---

力扣，回溯算法相关练习。

<!-- more -->

## 回溯模板

```cpp
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }
    for (范围：本层集合中的元素) {
        处理结点;
        backtracking(路径, 选择列表);
        回溯，撤销处理结果;
    }
}
```

## 组合问题

### [77. 组合](https://leetcode.cn/problems/combinations/)（中等）

首先可以确定四个参数，需要一个数组`path`来记录当其取到的元素，一个结果集`res`，还有`n`和`k`。

然后确定终止条件，当每次取够`k`个元素后就该存入结果集了，所以终止条件就是`path.size()==k`。

再来确定循环的范围，每次都需要从上一次取过的数的下一个数开始取，否则就重复取了，所以需要一个`startIdx`来指明开始取数的位置。这里需要再添加一个参数`startIdx`。每次取一个数放入`path`，然后递归处理，结束后再将这个数回溯。

```cpp
void backtracking(int n, int k, int startIdx, vector<int> &path,
                  vector<vector<int>> &res) {
    // path的大小与k相同时表明已经取完了
    if (path.size() == k) {
        res.push_back(path);
        return;
    }
    for (int i = startIdx; i <= n; i++) {
        path.push_back(i);                    // 处理当前结点
        backtracking(n, k, i + 1, path, res); // 递归
        path.pop_back();                      // 回溯，撤销选择的结点
    }
}

vector<vector<int>> combine(int n, int k) {
    vector<vector<int>> res; // 结果集
    vector<int> path;        // 存放符合条件的单个结果
    backtracking(n, k, 1, path, res);
    return res;
}
```

### [216. 组合总和 III](https://leetcode.cn/problems/combination-sum-iii/)（中等）

思路大体和上题相似，依然是首先确定参数，一个数组`path`记录当前取到的元素，一个变量`sum`存储当前`path`中元素之和，结果集`res`，还有`n`和`k`。这里的`sum`也可以不要，只不过需要每次判断的时候都求一次和，会增加复杂度。

终止条件就是取够`k`个元素，同时需要判断当前`sum`是否等于`n`。

循环的范围依然是需要一个`startIdx`来帮助确定取数的范围。

```cpp
void backtracking(vector<int> &path, int sum, vector<vector<int>> &res, int k,
                  int n, int startIdx) {
    if (sum > n) { // 剪枝
        return;
    }
    if (path.size() == k) { // 终止条件
        if (sum == n)
            res.push_back(path);
        return;
    }

    for (int i = startIdx; i <= 9; i++) {
        path.push_back(i);
        sum += i;
        backtracking(path, sum, res, k, n, i + 1);
        sum -= i;        // 回溯
        path.pop_back(); // 回溯
    }
}

vector<vector<int>> combinationSum3(int k, int n) {
    vector<vector<int>> res;
    vector<int> path;
    backtracking(path, 0, res, k, n, 1);

    return res;
}
```

## 分割问题

### [131. 分割回文串](https://leetcode.cn/problems/palindrome-partitioning/)（中等）

分割问题和组合问题很类似，只不过组合问题是寻找取元素的位置，分割问题是找分割元素的位置。

先确定回溯的参数，一个数组`path`来记录已分割的元素，结果集`res`，用于确定分割起始点的`startIdx`，以及字符串`s`。

终止条件就是分割起始点`startIdx`大于等于字符串的大小。

循环中判断当前子串是否为回文串，若是则取子串加入`path`，若不是则跳过本次循环。

同时本题还需要一个函数来判断字符串是否为回文串。

```cpp
bool isPalindrome(const string &s, int start, int end) {
    for (int i = start, j = end; i < j; i++, j--) {
        if (s[i] != s[j])
            return false;
    }
    return true;
}

void backtracking(vector<string> &path, vector<vector<string>> &res,
                  const string &s, int startIdx) {
    if (startIdx >= s.size()) {
        res.push_back(path);
        return;
    }
    for (int i = startIdx; i < s.size(); i++) {
        if (isPalindrome(s, startIdx, i)) { // 是回文串则加入path
            string str = s.substr(startIdx, i - startIdx + 1);
            path.push_back(str);
        } else { // 不是回文串则跳过
            continue;
        }
        backtracking(path, res, s, i + 1); // 寻找i+1起始的子串
        path.pop_back();                   // 回溯
    }
}

vector<vector<string>> partition(string s) {
    vector<vector<string>> res;
    vector<string> path;
    backtracking(path, res, s, 0);

    return res;
}
```

### [93. 复原 IP 地址](https://leetcode.cn/problems/restore-ip-addresses/)（中等）

先确定回溯所需参数，同样需要`startIdx`来记录分割的起始点，还需要一个`dotCount`来记录点的个数。

有了点的个数，终止条件自然就是点的个数等于3。

在循环中，要判断当前分割出来的部分是否合法，如果合法，则插入一个点，然后进一步递归处理。若不和法，直接结束本次循环。

判断合法性时，在`for`循环中只能判断分割的前三段是否合法，第四段的判断只能在终止条件满足时再判断。

```cpp
bool isValid(const string &s, int start, int end) {
    if (start > end)
        return false;

    if (s[start] == '0' && start != end) // 0开头的数字不合法
        return false;

    int num = 0;
    for (int i = start; i <= end; i++) {
        if (s[i] > '9' || s[i] < '0') // 非法字符
            return false;

        num = num * 10 + (s[i] - '0');
        if (num > 255) // 数值大于255不合法
            return false;
    }

    return true;
}

void backtracking(vector<string> &res, string &s, int startIdx, int dotCount) {
    if (dotCount == 3) { // 点的个数为3时终止
        // 判断第四段子串是否合法
        if (isValid(s, startIdx, s.size() - 1)) {
            res.push_back(s);
        }
        return;
    }

    for (int i = startIdx; i < s.size(); i++) {
        if (isValid(s, startIdx, i)) { // 判断[startIdx, i]区间内的子串是否合法
            s.insert(s.begin() + i + 1, '.'); // 位置i之后插入一个点
            dotCount++;
            backtracking(res, s, i + 2,
                         dotCount); // 插入点之后，下一个起始位置要+2
            dotCount--;             // 回溯
            s.erase(s.begin() + i + 1); // 回溯，删除插入的点
        } else {
            break; // 不合法直接结束循环
        }
    }
}

vector<string> restoreIpAddresses(string s) {
    vector<string> res;
    // 剪枝
    if (s.size() < 4 || s.size() > 12)
        return res;
    backtracking(res, s, 0, 0);

    return res;
}
```

