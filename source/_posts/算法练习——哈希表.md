---
title: 算法练习——哈希表
tags:
  - 算法
  - 哈希表
  - 力扣
categories: [算法,力扣]
toc: true
cover: https://user-images.githubusercontent.com/56388518/193993886-b75aa87e-7185-47e3-b76d-c9d3d423425a.png
abbrlink: 51387
date: 2022-03-18 16:42:39
---

力扣，哈希表相关练习。

<!--more-->

# 哈希表

## [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)（简单）

由于字符串中只有小写字母，故可以只用一个长度为26的数组做标记，先遍历字符串`s`，将下标为`[字符的ASCII码 - a的ASCII码]`处的标记加1，再遍历字符串`t`，将下标为`[字符的ASCII码 - a的ASCII码]`处的标记减1，最后遍历标志数组，若全为0则符合条件返回true，否则返回false。

```java
public boolean isAnagram(String s, String t) {
    int[] flag = new int[26];
    for (int i = 0; i < s.length(); i++)
        flag[s.charAt(i) - 'a']++;
    for (int i = 0; i < t.length(); i++)
        flag[t.charAt(i) - 'a']--;
    for (int i = 0; i < 26; i++)
        if (flag[i] != 0)
            return false;
    return true;
}
```

## [1002. 查找共用字符](https://leetcode-cn.com/problems/find-common-characters/)（简单）

本题需要一定的技巧，要统计所有单词中都出现的字母，需要为每个单词设置标记数组以统计每个单词中的字母出现频率，再将所有单词的标记数组进行比较，每个字母对应的标记数组的值中取最小，这个最小值即为这个字母在所有单词中都出现的次数。

![](https://camo.githubusercontent.com/d7f165b43baffeaed8114c1a8396081b46f9b2ad8a264217e8d2b99f5cf5af49/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f313030322e2545362539462541352545362538392542452545352542382542382545372539342541382545352541442539372545372541432541362e706e67)

```java
public List<String> commonChars(String[] words) {
    List<String> result = new ArrayList<>();
    if (words.length == 0) return result;
    int[] firstWord = new int[26];
    for (char item : words[0].toCharArray()) {
        firstWord[item - 'a']++;
    }
    for (int i = 1; i < words.length; i++) {
        int[] otherWords = new int[26];
        for (char item : words[i].toCharArray()) {
            otherWords[item - 'a']++;
        }
        for (int j = 0; j < 26; j++) {
            firstWord[j] = Math.min(firstWord[j], otherWords[j]);
        }
    }

    for (int i = 0; i < 26; i++) {
        while (firstWord[i] != 0) {
            result.add(String.valueOf((char) (i + 'a')));
            firstWord[i]--;
        }
    }

    return result;
}
```

## [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)（简单）

利用两个集合即可求出两数组的交集，先用一个集合存储第一个数组中出现过的元素，再遍历第二个数组，若第二个数组中的元素存在于第一个集合中，则说明两数组的交集中有该元素，故将该元素放入第二个集合中，最后将集合转化为`int`数组返回即可。

```java
public int[] intersection(int[] nums1, int[] nums2) {
    HashSet<Integer> integers = new HashSet<>();
    HashSet<Integer> result = new HashSet<>();
    for (int item : nums1) {
        integers.add(item);
    }
    int count = 0;
    for (int item : nums2) {
        if (integers.contains(item))
            result.add(item);
    }
    int[] resultArray = new int[result.size()];
    for (int i = 0; i < resultArray.length; i++) {
        resultArray[i] = (Integer) result.toArray()[i];
    }

    return resultArray;
}
```

## [202. 快乐数](https://leetcode-cn.com/problems/happy-number/)（简单）

要解决本题，关键是找到非快乐数的特点，以下以2为例说明：

- $2^2=4$
- $4^2=16$
- $1^2+6^2=37$
- $3^2+7^2=58$
- $5^2+8^2=89$
- $8^2+9^2=145$
- $1^2+4^2+5^2=42$
- $4^2+2^2=20$
- $2^2+0^2=4$

计算之后发现，非快乐数的运算结果一定会成为一个循环，这样就可以利用一个集合记录下求和的过程，一旦出现一个之前出现过的和，则认为该数的计算会一直循环下去，即该数为非快乐数。

```java
public boolean isHappy(int n) {
    HashSet<Integer> set = new HashSet<>();
    String num = String.valueOf(n);

    int sum = 0;
    while (sum != 1) {
        int temp = 0;
        for (char item : num.toCharArray()) {
            temp += Math.pow(Integer.parseInt(String.valueOf(item)), 2);
        }
        sum = temp;
        if (set.contains(temp)) {
            return false;
        }
        set.add(temp);
        num = String.valueOf(sum);
    }

    return true;
}
```

笔者解决本题时是将`int`型的数转化为字符串逐位处理，还可以采用如下方法，即对10取模后除以10的方式逐位处理。

```java
while (n > 0) {
    int temp = n % 10;// 对10取模得到个位数
    res += temp * temp;
    n = n / 10;// 除以10相当于将十进制数逻辑右移一位
}
```

## [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)（简单）

本题用暴力法解决的时间复杂度为$O(n^2)$，而用map解决可以达到$O(n)$。

解题思路为，将给定数组的元素和下标存放进map中，但要注意的是，map的key是用元素值充当的，value存放的是该元素的下标。

遍历给定数组，用`target - num[i]`，得到的值为当前遍历的元素与目标值的差值，若这个差值存在于`map`的`key`中，则当前元素与`map`中找到的元素之和即为`target`，此时两个元素的下标一个为`i`，另一个下标以差值为`key`在`map`中找到，否则就将当前元素按照上述方式存入`map`中，继续遍历下一个元素。

```java
public int[] twoSum(int[] nums, int target) {
    int[] result = new int[2];
    HashMap<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int temp = target - nums[i];
        if (map.containsKey(temp)) {
            result[1] = i;
            result[0] = map.get(temp);
        }
        map.put(nums[i], i);
    }

    return result;
}
```

## [383. 赎金信](https://leetcode-cn.com/problems/ransom-note/)（简单）

先遍历字符串`magazine`，将每个字符作为`key`存入`map`中，即记录下可以用的字母种类和数量，再遍历字符串`ransomNote`，检查每个字符是否存在于`map`中并有余量，若有某个字符不存在于`map`中或`map`中的`value`为0，则说明`ransomNote`不能由`magazine`字符串中的字符组成，返回`false`，反之返回`true`。

```java
public boolean canConstruct(String ransomNote, String magazine) {
    HashMap<Character, Integer> map = new HashMap<>();
    for (char item : magazine.toCharArray()) {
        if (map.containsKey(item)) {
            map.put(item, map.get(item) + 1);
        } else {
            map.put(item, 1);
        }
    }

    for (char item : ransomNote.toCharArray()) {
        if (map.containsKey(item)) {
            map.put(item, map.get(item) - 1);
            if (map.get(item) < 0) {
                return false;
            }
        } else {
            return false;
        }
    }

    return true;
}
```

## [454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)（中等）

该题与[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)类似，都是利用map存储一部分计算结果，再由另一部分计算结果与目标值的差值寻找最终答案。

```java
public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
    HashMap<Integer, Integer> map = new HashMap<>();
    int temp;
    int result = 0;
    // 统计两数组中的元素之和并记录出现的次数
    for (int i : nums1) {
        for (int j : nums2) {
            temp = i + j;
            if (map.containsKey(temp)) {
                map.put(temp, map.get(temp) + 1);
            } else {
                map.put(temp, 1);
            }
        }
    }
    for (int i : nums3) {
        for (int j : nums4) {
            temp = -(i + j);// 计算后两个数组的元素之和与0的差值
            if (map.containsKey(temp)) {// 在map中寻找前两个数组元素之和是否正好与该差值相等
                result += map.get(temp);
            }
        }
    }

    return result;
}
```

## [15. 三数之和](https://leetcode-cn.com/problems/3sum/)（中等）

本题使用哈希法在去重的时候会非常困难，且效率并不高，如下是哈希法的代码。

```java
public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> res = new ArrayList<>();
    // 对数组进行排序
    Arrays.sort(nums);
    // a = nums[i], b = nums[j], c = -(a + b)
    for (int i = 0; i < nums.length; i++) {
        // 若排序后的第一个数就大于0，则不可能凑成和为0的三元组
        if (nums[i] > 0) break;
        // 三元组对a进行去重，若当前的a与上一个a相同，则跳过本轮循环
        if (i > 0 && nums[i] == nums[i - 1]) continue;
        // 该HashSet用来判断是否存在c满足c = -(a + b)
        HashSet<Integer> set = new HashSet<>();
        for (int j = i + 1; j < nums.length; j++) {
            // 三元组对b进行去重，若当前数与之前两个数都相等，则跳过本轮循环
            // j > i + 2的目的是保证第一次遇到的数不被去重
            if (j > i + 2 && nums[j] == nums[j - 1] && nums[j - 1] == nums[j - 2]) continue;
            int c = -(nums[i] + nums[j]);
            // 若Set中存在满足条件的c，则说明找到了一个三元组，将之添加进结果集中
            if (set.contains(c)) {
                List<Integer> tuple = new ArrayList<>();
                tuple.add(nums[i]);
                tuple.add(nums[j]);
                tuple.add(c);
                res.add(tuple);
                set.remove(c);// 三元组对c进行去重
            } else {// 若Set中不存在这样的c，则将nums[j]添加进Set中
                set.add(nums[j]);
            }
        }
    }

    return res;
}
```

在哈希法中，去重的过程有很多细节需要注意，实现难度较大。

本题还可以用双指针法解决：

- 先将一个指针`i`指向一个元素充当a；
- 然后设置两个指针`left`和`right`分别指向`i+1`位置的元素和数组末尾元素；

接下来利用`i`遍历整个数组，每次移动指针都进行判断：

- 若`nums[i] + nums[left] + nums[right] > 0`则需要将`right`指针向左移动，以减小三数之和；
- 若`nums[i] + nums[left] + nums[right] < 0`则需要将`left`指针向右移动，以增大三数之和；
- 若`nums[i] + nums[left] + nums[right] = 0`则说明找到了一个三元组，将之加入结果集。

在遍历过程中还需要注意去重的操作，详见代码中的注释。

```java
public List<List<Integer>> threeSum(int[] nums) {
    List<List<Integer>> res = new ArrayList<>();
    Arrays.sort(nums);

    for (int i = 0; i < nums.length; i++) {
        if (nums[i] > 0) return res;

        // 三元组对a进行去重
        if (i > 0 && nums[i] == nums[i - 1]) continue;
        // 左指针指向nums[i]的下一个数，右指针指向数组末尾
        int left = i + 1;
        int right = nums.length - 1;
        while (left < right) {
            // 由于数组是排过序的，若此时和大于0，说明需要减小右指针所指的数，故右指针左移
            if (nums[i] + nums[left] + nums[right] > 0) {
                right--;
                // 当前元素已经不合适了，故一直左移直到出现新的元素
                while (left < right && nums[right] == nums[right + 1]) right--;
            } else if (nums[i] + nums[left] + nums[right] < 0) {// 若和小于0，则左指针右移，增大数字
                left++;
                // 当前元素已经不合适了，故一直右移直到出现新的元素
                while (left < right && nums[left] == nums[left - 1]) left++;
            } else {
                List<Integer> tuple = new ArrayList<>();
                tuple.add(nums[i]);
                tuple.add(nums[left]);
                tuple.add(nums[right]);
                res.add(tuple);
                // 当前左右指针所指的数字均符合要求
                // 此时需要去掉左指针右侧与当前左指针所指数字相同的数字
                // 同理去掉右指针左侧与当前右指针所指数字相同的数字
                while (left < right && nums[right] == nums[right - 1]) right--;
                while (left < right && nums[left] == nums[left + 1]) left++;

                // 找到一个三元组后，双指针同时收缩
                right--;
                left++;
            }
        }
    }

    return res;
}
```



## [18. 四数之和](https://leetcode-cn.com/problems/4sum/)（待解决）（中等）

```java

```

