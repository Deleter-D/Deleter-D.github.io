---
title: 算法练习——哈希表
tags:
  - 算法
  - 哈希表
  - 力扣
categories: 算法
cover: >-
  https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fimg9.51tietu.net%2Fpic%2F2019-091122%2Fjrh3rt02v3cjrh3rt02v3c.jpg&refer=http%3A%2F%2Fimg9.51tietu.net&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1650184993&t=b36245a8d84c3ee1b59548cfa79c6e9e
abbrlink: 51387
date: 2022-03-18 16:42:39
---

# 哈希表

## [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)（简单）

由于字符串中只有小写字母，故可以只用一个长度为26的数组做标记，先遍历字符串`s`，将下标为`[字符的ASCII码 - a的ASCII码]`处的标记加1，再遍历字符串`t`，将下标为`[字符的ASCII码 - a的ASCII码]`处的标记减1，最后遍历标志数组，若全为0则符合条件返回true，否则返回false。

```java
public boolean isAnagram(String s, String t) {
    int[] flag = new int[26];
    for (int i = 0; i < s.length(); i++)
        flag[s.charAt(i) - 'a']++;
    for (int i = 0; i < t.length(); i++)
        flag[t.charAt(i) - 'a']--;
    for (int i = 0; i < 26; i++)
        if (flag[i] != 0)
            return false;
    return true;
}
```

## [1002. 查找共用字符](https://leetcode-cn.com/problems/find-common-characters/)（简单）

本题需要一定的技巧，要统计所有单词中都出现的字母，需要为每个单词设置标记数组以统计每个单词中的字母出现频率，再将所有单词的标记数组进行比较，每个字母对应的标记数组的值中取最小，这个最小值即为这个字母在所有单词中都出现的次数。

![](https://camo.githubusercontent.com/d7f165b43baffeaed8114c1a8396081b46f9b2ad8a264217e8d2b99f5cf5af49/68747470733a2f2f636f64652d7468696e6b696e672e63646e2e626365626f732e636f6d2f706963732f313030322e2545362539462541352545362538392542452545352542382542382545372539342541382545352541442539372545372541432541362e706e67)

```java
public List<String> commonChars(String[] words) {
    List<String> result = new ArrayList<>();
    if (words.length == 0) return result;
    int[] firstWord = new int[26];
    for (char item : words[0].toCharArray()) {
        firstWord[item - 'a']++;
    }
    for (int i = 1; i < words.length; i++) {
        int[] otherWords = new int[26];
        for (char item : words[i].toCharArray()) {
            otherWords[item - 'a']++;
        }
        for (int j = 0; j < 26; j++) {
            firstWord[j] = Math.min(firstWord[j], otherWords[j]);
        }
    }

    for (int i = 0; i < 26; i++) {
        while (firstWord[i] != 0) {
            result.add(String.valueOf((char) (i + 'a')));
            firstWord[i]--;
        }
    }

    return result;
}
```

## [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)（简单）

利用两个集合即可求出两数组的交集，先用一个集合存储第一个数组中出现过的元素，再遍历第二个数组，若第二个数组中的元素存在于第一个集合中，则说明两数组的交集中有该元素，故将该元素放入第二个集合中，最后将集合转化为`int`数组返回即可。

```java
public int[] intersection(int[] nums1, int[] nums2) {
    HashSet<Integer> integers = new HashSet<>();
    HashSet<Integer> result = new HashSet<>();
    for (int item : nums1) {
        integers.add(item);
    }
    int count = 0;
    for (int item : nums2) {
        if (integers.contains(item))
            result.add(item);
    }
    int[] resultArray = new int[result.size()];
    for (int i = 0; i < resultArray.length; i++) {
        resultArray[i] = (Integer) result.toArray()[i];
    }

    return resultArray;
}
```

## [202. 快乐数](https://leetcode-cn.com/problems/happy-number/)（简单）

要解决本题，关键是找到非快乐数的特点，以下以2为例说明：

- $2^2=4$
- $4^2=16$
- $1^2+6^2=37$
- $3^2+7^2=58$
- $5^2+8^2=89$
- $8^2+9^2=145$
- $1^2+4^2+5^2=42$
- $4^2+2^2=20$
- $2^2+0^2=4$

计算之后发现，非快乐数的运算结果一定会成为一个循环，这样就可以利用一个集合记录下求和的过程，一旦出现一个之前出现过的和，则认为该数的计算会一直循环下去，即该数为非快乐数。

```java
public boolean isHappy(int n) {
    HashSet<Integer> set = new HashSet<>();
    String num = String.valueOf(n);

    int sum = 0;
    while (sum != 1) {
        int temp = 0;
        for (char item : num.toCharArray()) {
            temp += Math.pow(Integer.parseInt(String.valueOf(item)), 2);
        }
        sum = temp;
        if (set.contains(temp)) {
            return false;
        }
        set.add(temp);
        num = String.valueOf(sum);
    }

    return true;
}
```

笔者解决本题时是将`int`型的数转化为字符串逐位处理，还可以采用如下方法，即对10取模后除以10的方式逐位处理。

```java
while (n > 0) {
    int temp = n % 10;// 对10取模得到个位数
    res += temp * temp;
    n = n / 10;// 除以10相当于将十进制数逻辑右移一位
}
```

## [1. 两数之和](https://leetcode-cn.com/problems/two-sum/)（简单）

本题用暴力法解决的时间复杂度为$O(n^2)$，而用map解决可以达到$O(n)$。

解题思路为，将给定数组的元素和下标存放进map中，但要注意的是，map的key是用元素值充当的，value存放的是该元素的下标。

遍历给定数组，用`target - num[i]`，得到的值为当前遍历的元素与目标值的差值，若这个差值存在于`map`的`key`中，则当前元素与`map`中找到的元素之和即为`target`，此时两个元素的下标一个为`i`，另一个下标以差值为`key`在`map`中找到，否则就将当前元素按照上述方式存入`map`中，继续遍历下一个元素。

```java
public int[] twoSum(int[] nums, int target) {
    int[] result = new int[2];
    HashMap<Integer, Integer> map = new HashMap<>();
    for (int i = 0; i < nums.length; i++) {
        int temp = target - nums[i];
        if (map.containsKey(temp)) {
            result[1] = i;
            result[0] = map.get(temp);
        }
        map.put(nums[i], i);
    }

    return result;
}
```

## [383. 赎金信](https://leetcode-cn.com/problems/ransom-note/)（简单）

先遍历字符串`magazine`，将每个字符作为`key`存入`map`中，即记录下可以用的字母种类和数量，再遍历字符串`ransomNote`，检查每个字符是否存在于`map`中并有余量，若有某个字符不存在于`map`中或`map`中的`value`为0，则说明`ransomNote`不能由`magazine`字符串中的字符组成，返回`false`，反之返回`true`。

```java
public boolean canConstruct(String ransomNote, String magazine) {
    HashMap<Character, Integer> map = new HashMap<>();
    for (char item : magazine.toCharArray()) {
        if (map.containsKey(item)) {
            map.put(item, map.get(item) + 1);
        } else {
            map.put(item, 1);
        }
    }

    for (char item : ransomNote.toCharArray()) {
        if (map.containsKey(item)) {
            map.put(item, map.get(item) - 1);
            if (map.get(item) < 0) {
                return false;
            }
        } else {
            return false;
        }
    }

    return true;
}
```

## [454. 四数相加 II](https://leetcode-cn.com/problems/4sum-ii/)（中等）

该题与[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)类似，都是利用map存储一部分计算结果，再由另一部分计算结果与目标值的差值寻找最终答案。

```java
public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
    HashMap<Integer, Integer> map = new HashMap<>();
    int temp;
    int result = 0;
    // 统计两数组中的元素之和并记录出现的次数
    for (int i : nums1) {
        for (int j : nums2) {
            temp = i + j;
            if (map.containsKey(temp)) {
                map.put(temp, map.get(temp) + 1);
            } else {
                map.put(temp, 1);
            }
        }
    }
    for (int i : nums3) {
        for (int j : nums4) {
            temp = -(i + j);// 计算后两个数组的元素之和与0的差值
            if (map.containsKey(temp)) {// 在map中寻找前两个数组元素之和是否正好与该差值相等
                result += map.get(temp);
            }
        }
    }

    return result;
}
```

## [15. 三数之和](https://leetcode-cn.com/problems/3sum/)（待解决）（中等）

```java

```

## [18. 四数之和](https://leetcode-cn.com/problems/4sum/)（待解决）（中等）

```java

```

