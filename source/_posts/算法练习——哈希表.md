---
title: 算法练习——哈希表
tags:
  - 算法
  - 哈希表
  - 力扣
categories: [算法,力扣]
toc: true
cover: https://user-images.githubusercontent.com/56388518/193993886-b75aa87e-7185-47e3-b76d-c9d3d423425a.png
abbrlink: 51387
date: 2022-03-18 16:42:39
---

力扣，哈希表相关练习。

<!--more-->

## [242. 有效的字母异位词](https://leetcode-cn.com/problems/valid-anagram/)（简单）

本题可以利用`map`来统计两个字符串出现过的字符数量，最后比较相同字母出现的次数是否全部相等即可。要注意的一点是，比较时一定要遍历较长的`map`，否则可能导致较短`map`对应的字符串中没有出现过的字符未得到判断。

```java
bool isAnagram(string s, string t) {
    map<char, int> s_counter, t_counter;
    for (char c : s) { // 统计s字符串出现字母的数量
        s_counter[c]++;
    }
    for (char c : t) { // 统计t字符串出现字母的数量
        t_counter[c]++;
    }

    if (s_counter.size() < t_counter.size()) // 为了遍历出现字母更多的map而交换
        swap(s_counter, t_counter);

    for (auto begin = s_counter.cbegin(); begin != s_counter.cend(); begin++) {
        if (t_counter[begin->first] != begin->second)
            return false;
    }

    return true;
}
```

## [349. 两个数组的交集](https://leetcode-cn.com/problems/intersection-of-two-arrays/)（简单）

判断一个元素是否出现过，自然而然想到了用`set`来解决。由于没有顺序要求，所以使用`unordered_set`来省去排序的过程。

```cpp
vector<int> intersection(vector<int> &nums1, vector<int> &nums2) {
    unordered_set<int> res; // 为了去重，结果暂时存放在set中
    // 将nums1的数据存入一个set去重
    unordered_set<int> nums_set(nums1.cbegin(), nums1.cend());
    for (int num : nums2) {
        // 判断nums2中的数有没有在nums1中出现过
        if (nums_set.find(num) != nums_set.cend()) {
            res.insert(num);
        }
    }

    return vector<int>(res.cbegin(), res.cend());
}
```

## [202. 快乐数](https://leetcode.cn/problems/intersection-of-two-arrays/)（简单）

本题有一个关键线索就是无限循环，表明非快乐数求每位数字的平方和时，这个平方和会重复出现。这时就又回到了判断元素是否重复的问题了，使用`unordered_set`来判断即可。

```cpp
vector<int> getNums(int n) { // 获取数字的每一位
    vector<int> nums;
    while (n != 0) {
        nums.push_back(n % 10);
        n /= 10;
    }
    return nums;
}

bool isHappy(int n) {
    unordered_set<int> sums;
    while (true) {
        vector<int> nums = getNums(n);
        int sum = 0;
        for (int num : nums) {
            sum += num * num; // 计算每一位数的平方和
        }
        if (sum == 1)
            return true;

        if (sums.find(sum) != sums.cend())
            return false; // 若和之前出现过，则为非快乐数
        else {
            sums.insert(sum);
            n = sum;
        }
    }
}
```

## [1. 两数之和](https://leetcode.cn/problems/two-sum/)（简单）

本题暴力解法当然可行，这也是这道题可以作为简单题出现的理由。但本题可以采用另一种角度来思考，想要找到当前数符合要求的另一个数字，可以试图找当前数与目标数的差值。这就将问题转换为了寻找某个元素是否出现过，自然而然的使用哈希表。但由于这里需要返回的是下标，所以不仅要记录值本身，还需要记录对应的下标，使用`map`最为合适。并且对`key`没有排序的要求，可以使用`unordered_map`来省去排序过程。

```cpp
vector<int> twoSum(vector<int> &nums, int target) {
    unordered_map<int, int> record; // 记录出现过的数字和下标
    for (int i = 0; i < nums.size(); i++) {
        // 寻找目标数与当前数的差值是否出现过
        auto iter = record.find(target - nums[i]);
        if (iter != record.cend()) {
            return {i, iter->second};
        }
        record[nums[i]] = i; // 没有出现则将当前数记录下来
    }
    return {};
}
```

## [454. 四数相加II](https://leetcode.cn/problems/4sum-ii/)（中等）

这道题可以沿用[两数之和](#1. 两数之和（简单）)的思想，将4个数组分为两组。从这两组的视角来看，他们就变成了两数之和，只不过目标值永远为0。先统计前两个数组中每对数之和，由于可能存在不同对的和相同的情况，所以需要记录下出现过的次数，这里使用`unordered_map`。然后再对后两个数组进行遍历，再`map`中查询0与每对数之和的差值是否出现过，若出现过则证明有四元组符合要求，而且符合要求的个数是`map`中所记录的个数。

```cpp
int fourSumCount(vector<int> &nums1, vector<int> &nums2, vector<int> &nums3,
                 vector<int> &nums4) {
    unordered_map<int, int> record; // 记录前两个数组出现过的和
    for (int num1 : nums1) {
        for (int num2 : nums2) {
            record[num1 + num2]++;
        }
    }
    int count = 0;
    for (int num3 : nums3) {
        for (int num4 : nums4) {
            // 判断0与后两个数组出现的和的差值是否出现过
            if (record.find(0 - (num3 + num4)) != record.cend()) {
                count += record[0 - (num3 + num4)];
            }
        }
    }
    return count;
}
```

## [383. 赎金信](https://leetcode.cn/problems/ransom-note/)（简单）

本题还是判断元素是否存在的问题，但本题中涉及重复元素，可以使用`multiset`。遍历`magazine`字符串，将出现过的字符都存入`multiset`中。然后遍历`ransomNote`，将出现过的字符一一从`multiset`中去掉，一旦发现`multiset`中没有的字符，则证明`ransomNote`无法由`maganize`中的字符构成。

```cpp
bool canConstruct(string ransomNote, string magazine) {
    multiset<char> record(magazine.cbegin(), magazine.cend());
    for (char c : ransomNote) {
        auto iter = record.find(c);
        if (iter != record.cend()) {
            record.erase(iter);
        } else {
            return false;
        }
    }

    return true;
}
```

但本题有一个很重要的条件，两个字符串都只由小写字母构成，这意味着只会有26种字符。此时可以使用一个长度为26的数组来记录每个字符出现的次数，从而省去`multiset`的各种操作，毕竟底层是红黑树，操作代价比较大。

```cpp
bool canConstruct(string ransomNote, string magazine) {
    vector<int> record(26, 0);
    if (ransomNote.size() > magazine.size())
        return false;

    for (char c : magazine) {
        record[c - 'a']++;
    }
    for (char c : ransomNote) {
        record[c - 'a']--;
        if (record[c - 'a'] < 0)
            return false;
    }

    return true;
}
```

## [15. 三数之和](https://leetcode.cn/problems/3sum/)（中等）

本题可以沿用[两数之和](#1. 两数之和（简单）)的思路，用一个双层`for`循环来确定三元组前两个元素的值，然后再判断0与前两个值的差值是否在数组里出现过即可。但题目中有一个关键的要求是，不允许包含重复的三元组，所以涉及到一系列的去重操作。

```cpp
vector<vector<int>> threeSum(vector<int> &nums) {
    vector<vector<int>> res;
    sort(nums.begin(), nums.end());

    for (int i = 0; i < nums.size(); i++) {
        // 若排序之后的第一个元素已经大于0，则不可能有满足条件的三元组
        if (nums[i] > 0)
            break;
        // 三元组第一个元素去重
        if (i > 0 && nums[i] == nums[i - 1])
            continue;

        unordered_set<int> record;
        for (int j = i + 1; j < nums.size(); j++) {
            // 三元组第二个元素去重
            if (j > i + 2 && nums[j] == nums[j - 1] &&
                nums[j - 1] == nums[j - 2])
                continue;

            int c = 0 - (nums[i] + nums[j]);
            if (record.find(c) != record.cend()) {
                res.push_back({nums[i], nums[j], c});
                // 三元组第三个元素去重
                record.erase(c);
            } else {
                record.insert(nums[j]);
            }
        }
    }

    return res;
}
```

这样的解法不仅要考虑复杂的去重问题，还无法有效的剪枝，所以耗时非常严重。

本题可以采用另一个解法，同样先将数组排序。然后定义三个指针，第一个指针`i`从0开始遍历数组，第二个指针`left`指向`i+1`位置，第三个指针`right`指向数组的最后一个元素。

- 当`nums[i] + nums[left] + nums[right] > 0`时，说明三数之和大了，由于数组已经排序，所以必须让`right`向左移动，使三数之和变小。
- 当`nums[i] + nums[left] + nums[right] < 0`时，说明三数之和小了，必须让`left`向右移动，使三数之和变大。

直到`left`和`right`相邻。

```cpp
vector<vector<int>> threeSum2(vector<int> &nums) {
    vector<vector<int>> res;
    sort(nums.begin(), nums.end());

    for (int i = 0; i < nums.size(); i++) {
        if (nums[i] > 0)
            break;
        // 三元组第一个元素去重
        if (i > 0 && nums[i] == nums[i - 1])
            continue;

        int left = i + 1;
        int right = nums.size() - 1;
        while (left < right) {
            int sum = nums[i] + nums[left] + nums[right];
            if (sum > 0)
                right--;
            else if (sum < 0)
                left++;
            else {
                res.push_back({nums[i], nums[left], nums[right]});
                // 三元组第二个元素去重
                while (left < right && nums[right] == nums[right - 1])
                    right--;
                // 三元组第三个元素去重
                while (left < right && nums[left] == nums[left + 1])
                    left++;

                // 找到符合条件的三元组后两个指针同时收缩
                left++;
                right--;
            }
        }
    }

    return res;
}
```

本题的关键就在于去重。关于`nums[i]`的去重，如果`nums[i]`重复了，则应该直接跳过，因为它是最外层的循环。但问题的关键是判断重复的条件应该是`nums[i] == nums[i - 1]`还是`nums[i] == nums[i + 1]`。如果是`nums[i] == nums[i + 1]`则是判断当前数与下一个数是否相等，这样会导致三元组本身存在重复数字的情况被直接排除，例如`{-1, -1, 2}`。所以应该使用`nums[i] == nums[i - 1]`来判断第一个元素的去重。

## [18. 四数之和](https://leetcode.cn/problems/4sum/)（中等）

本题沿用[三数之和](#15. 三数之和（中等）)多指针解法的思路即可，但要注意几个点。三数之和用最外层循环来固定三元组的第一个元素，这里的四数之和就需要两层循环来固定四元组的前两个元素。

第一层循环剪枝的时候，不能像三数之和那样简单判断`nums[i] > target`就剪枝，例如`-4 > -10`这种情况不可以被剪掉。所以需要附加一个`nums[i] >= 0`的条件，此时才能剪枝。

第二层循环还可以进行剪枝，与第一层同理，不能简单判断`nums[i] + nums[j] > target`就剪枝，需要`nums[i] + nums[j] >= 0`的情况才能剪枝。

一旦固定前两个元素，后续的思路和三数之和就一模一样了。

```cpp
vector<vector<int>> fourSum(vector<int> &nums, int target) {
    vector<vector<int>> res;
    sort(nums.begin(), nums.end());

    for (int i = 0; i < nums.size(); i++) {
        // 第一层剪枝，但不能简单的因为nums[i] > target就剪枝
        if (nums[i] > target && nums[i] >= 0)
            break;
        // 对四元组第一个元素去重
        if (i > 0 && nums[i] == nums[i - 1])
            continue;

        for (int j = i + 1; j < nums.size(); j++) {
            // 第二层剪枝，条件判断与第一层同理
            if (nums[i] + nums[j] > target && nums[i] + nums[j] >= 0)
                break;

            // 对四元组第二个元素去重
            if (j > i + 1 && nums[j] == nums[j - 1])
                continue;

            int left = j + 1;
            int right = nums.size() - 1;
            while (left < right) {
                // 用long类型防止溢出
                long sum = (long)nums[i] + nums[j] + nums[left] + nums[right];
                if (sum > target)
                    right--;
                else if (sum < target)
                    left++;
                else {
                    res.push_back({nums[i], nums[j], nums[left], nums[right]});
                    // 对四元组第三个元素去重
                    while (left < right && nums[right] == nums[right - 1])
                        right--;
                    // 对四元组第四个元素去重
                    while (left < right && nums[left] == nums[left + 1])
                        left++;

                    left++;
                    right--;
                }
            }
        }
    }

    return res;
}
```



