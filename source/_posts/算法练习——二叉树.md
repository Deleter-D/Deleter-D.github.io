---
title: 算法练习——二叉树
tags:
  - 算法
  - 二叉树
  - 力扣
categories: [算法,力扣]
toc: true
cover: https://user-images.githubusercontent.com/56388518/193994116-bb24a164-ed0b-475f-9250-29278b14e043.png
abbrlink: 41828
date: 2022-05-03 17:18:40
---

力扣，二叉树相关练习。

<!--more-->

# 二叉树

## 二叉树的遍历

### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)（简单）

递归方式

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    preOrder(root, res);

    return res;
}

public void preOrder(TreeNode root, List<Integer> res) {
    if (root != null) {
        res.add(root.val);
        preOrder(root.left, res);
        preOrder(root.right, res);
    }
}
```

迭代方式

```java
public List<Integer> preorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    if (root == null) return res;

    Stack<TreeNode> stack = new Stack<>();
    stack.push(root);
    while (!stack.isEmpty()) {
        TreeNode node = stack.pop();
        res.add(node.val);
        if (node.right != null) {
            stack.push(node.right);
        }
        if (node.left != null) {
            stack.push(node.left);
        }
    }

    return res;
}
```

### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)（简单）

递归方式

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    inOrder(root, res);

    return res;
}

public void inOrder(TreeNode root, List<Integer> res) {
    if (root != null) {
        inOrder(root.left, res);
        res.add(root.val);
        inOrder(root.right, res);
    }
}
```

迭代方式

```java
public List<Integer> inorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    if (root == null) return res;

    Stack<TreeNode> stack = new Stack<>();
    TreeNode pointer = root;
    while (pointer != null || !stack.isEmpty()) {
        if (pointer != null) {
            stack.push(pointer);
            pointer = pointer.left;
        } else {
            pointer = stack.pop();
            res.add(pointer.val);
            pointer = pointer.right;
        }
    }

    return res;
}
```

### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)（简单）

递归方式

```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    postOrder(root, res);

    return res;
}

public void postOrder(TreeNode root, List<Integer> res) {
    if (root != null) {
        postOrder(root.left, res);
        postOrder(root.right, res);
        res.add(root.val);
    }
}
```

迭代方式

```java
public List<Integer> postorderTraversal(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    if (root == null) return res;

    Stack<TreeNode> stack = new Stack<>();
    TreeNode pointer = root;
    TreeNode record = new TreeNode();
    while (pointer != null || !stack.isEmpty()) {
        if (pointer != null) {
            stack.push(pointer);
            pointer = pointer.left;
        } else {
            pointer = stack.peek();
            if (pointer.right != null && pointer.right != record) {
                pointer = pointer.right;
            } else {
                pointer = stack.pop();
                res.add(pointer.val);
                record = pointer;
                pointer = null;
            }
        }
    }

    return res;
}
```

### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)（中等）

递归方式

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    lOrder(root, 0, res);

    return res;
}

public void lOrder(TreeNode root, int deep, List<List<Integer>> res) {
    if (root == null) return;
    deep++;
    // deep随着递归深度增加而增加，当res的size小于deep时表明当前层已访问完毕
    if (res.size() < deep) {
        List<Integer> level = new ArrayList<>();
        res.add(level);
    }
    res.get(deep - 1).add(root.val);
    lOrder(root.left, deep, res);
    lOrder(root.right, deep, res);
}
```

迭代方式

```java
public List<List<Integer>> levelOrder(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null) return res;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        List<Integer> level = new ArrayList<>();
        // 利用size记录本层结点数
        int size = queue.size();
        // 当size==0时表示该层结点访问完毕
        while (size > 0) {
            TreeNode pointer = queue.poll();
            level.add(pointer.val);
            if (pointer.left != null) queue.offer(pointer.left);
            if (pointer.right != null) queue.offer(pointer.right);
            size--;
        }
        res.add(level);
    }

    return res;
}
```

## 层序遍历衍生题目

### [107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)（中等）

正常将二叉树层序遍历，最后将遍历结果数组逆置即可。

```java
public List<List<Integer>> levelOrderBottom(TreeNode root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null) return res;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        List<Integer> level = new ArrayList<>();
        int size = queue.size();
        while (size > 0) {
            TreeNode pointer = queue.poll();
            level.add(pointer.val);
            if (pointer.left != null) queue.offer(pointer.left);
            if (pointer.right != null) queue.offer(pointer.right);
            size--;
        }
        res.add(level);
    }
    List<List<Integer>> result = new ArrayList<>();
    for (int i = res.size() - 1; i >= 0; i--) {
        result.add(res.get(i));
    }

    return result;
}
```

### [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)（中等）

层序遍历二叉树时，判断当前元素是否为本层最后一个元素，若是则放入结果集。

```java
public List<Integer> rightSideView(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    if (root == null) return res;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        while (size > 0) {
            TreeNode pointer = queue.poll();
            // 判断是否为本层最后一个元素
            if (size==1) res.add(pointer.val);
            if (pointer.left != null) queue.offer(pointer.left);
            if (pointer.right != null) queue.offer(pointer.right);
            size--;
        }
    }

    return res;
}
```

### [637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)（简单）

在层序遍历的同时，计算出每层结点的和，遍历完当前层后将该层的平均值放入结果集。

```java
public List<Double> averageOfLevels(TreeNode root) {
    List<Double> res = new ArrayList<>();
    if (root == null) return res;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        int count = queue.size();// 多记录一个size作为计算平均值的除数
        double levelSum = 0;
        while (size > 0) {
            TreeNode pointer = queue.poll();
            levelSum += pointer.val;
            if (pointer.left != null) queue.offer(pointer.left);
            if (pointer.right != null) queue.offer(pointer.right);
            size--;
        }
        res.add(levelSum / count);
    }

    return res;
}
```

### [429. N 叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)（中等）

与二叉树层序遍历类似，只需要在遍历当前结点的孩子结点时改为for循环，以保证遍历到该结点的每一个孩子节点。

```java
public List<List<Integer>> levelOrder(Node root) {
    List<List<Integer>> res = new ArrayList<>();
    if (root == null) return res;

    Queue<Node> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        List<Integer> level = new ArrayList<>();
        while (size > 0) {
            Node pointer = queue.poll();
            level.add(pointer.val);
            for (Node child : pointer.children) {
                if (child != null) queue.offer(child);
            }
            size--;
        }
        res.add(level);
    }

    return res;
}
```

### [515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)（中等）

层序遍历二叉树的过程中，找出每层的最大值放入结果集即可。

```java
public List<Integer> largestValues(TreeNode root) {
    List<Integer> res = new ArrayList<>();
    if (root == null) return res;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        int max = queue.peek().val;
        while (size > 0) {
            TreeNode pointer = queue.poll();
            if (pointer.val > max) max = pointer.val;
            if (pointer.left != null) queue.offer(pointer.left);
            if (pointer.right != null) queue.offer(pointer.right);
            size--;
        }
        res.add(max);
    }

    return res;
}
```

### [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)（中等）

层序遍历过程中，判断当前遍历结点在本层是否有后继结点，若有则将next指向它的后继结点，若没有则置为null。

```java
public Node connect(Node root) {
    if (root == null) return null;

    Queue<Node> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        while (size > 0) {
            Node pointer = queue.poll();
            if (size == 1) pointer.next = null;
            else pointer.next = queue.peek();
            if (pointer.left != null) queue.offer(pointer.left);
            if (pointer.right != null) queue.offer(pointer.right);
            size--;
        }
    }

    return root;
}
```

### [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)（中等）

与[116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)题没有任何差别。

```java
public Node connect(Node root) {
    if (root == null) return null;

    Queue<Node> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        while (size > 0) {
            Node pointer = queue.poll();
            if (size == 1) pointer.next = null;
            else pointer.next = queue.peek();
            if (pointer.left != null) queue.offer(pointer.left);
            if (pointer.right != null) queue.offer(pointer.right);
            size--;
        }
    }

    return root;
}
```



## 二叉树的属性

### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)（简单）

递归方式

```java
public boolean isSymmetric(TreeNode root) {
    if (root == null) return true;
    return compare(root.left, root.right);
}

// 此处传入的left和right指的是镜像对称的两个结点，并非一个结点的左右孩子
public boolean compare(TreeNode left, TreeNode right) {
    if (left == null && right != null) return false;
    else if (left != null && right == null) return false;
    else if (left == null && right == null) return true;
    // 以上处理了存在空结点的情况
    // 下面一行处理了两个结点都不为空，但数值不等的情况
    else if (left.val != right.val) return false;
    // 剩下的就是结点都存在且数值相等的情况，则递归的向下判断
    else return compare(left.left, right.right) && compare(left.right, right.left);
}
```

迭代方式

```java
public boolean isSymmetric(TreeNode root) {
    if (root == null) return true;
    Queue<TreeNode> queue = new LinkedList<>();// 此处也可以用栈
    queue.offer(root.left);
    queue.offer(root.right);

    while (!queue.isEmpty()) {
        // 此处的left和right与递归方法中参数的意义一致，是镜像对称的两个结点
        TreeNode left = queue.poll();
        TreeNode right = queue.poll();
        // 左右两个结点均为空，则返回true
        if (left == null && right == null) continue;
        // 若左右有一个结点不为空，或都不为空但数值不等，则返回false
        if (left == null || right == null || left.val != right.val) return false;

        queue.offer(left.left);// 左结点的左孩子入队
        queue.offer(right.right);// 右结点的右孩子入队
        queue.offer(left.right);// 左结点的右孩子入队
        queue.offer(right.left);// 右结点的左孩子入队
    }

    return true;
}
```

### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)（简单）

利用递归后序遍历的思想：

- 递归终止条件为访问到叶子结点，叶子结点的高度为1
- 先递归求得左、右子树的高度，取较大者再加一得到根结点的高度

整体代码如下：

```java
public int maxDepth(TreeNode root) {
    if (root == null) return 0;
    if (root.left == null && root.right == null) return 1;
    return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));
}
```

将最后一句的逻辑拆开即为：

```java
int leftDepth = maxDepth(root.left);// 左
int rightDepth = maxDepth(root.left);// 右
int depth = 1 + Math.max(leftDepth, rightDepth);// 根
```

当然也可以利用前序遍历来解决，涉及到回溯的思想

```java
public int res;

public int maxDepth(TreeNode root) {
    res = 0;
    if (root == null) return res;
    getDepth(root, 1);

    return res;
}

public void getDepth(TreeNode root, int depth) {
    res = Math.max(depth, res);// 根
    if (root.left == null && root.right == null) return;
    // 若左右孩子不为null，则继续访问，故深度需加一
    if (root.left != null) getDepth(root.left, depth + 1);// 左
    if (root.right != null) getDepth(root.right, depth + 1);// 右

    return;
}
```

也可利用层序遍历思想，层序遍历过程中每遍历完一层深度加一，最后返回深度即可。

```java
public int maxDepth(TreeNode root) {
    int depth = 0;
    if (root == null) return depth;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        while (size > 0) {
            TreeNode pointer = queue.poll();
            if (pointer.left != null) queue.offer(pointer.left);
            if (pointer.right != null) queue.offer(pointer.right);
            size--;
        }
        depth++;
    }

    return depth;
}
```

### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)（简单）

与上题类似，利用后序遍历的思想，值得注意的是：

- 当左子树为空时，最小深度为右子树的最小深度
- 当右子树为空时，最小深度为左子树的最小深度
- 当左右子树都不空时，最小深度为左、右子树最小深度的较小者

```java
public int minDepth(TreeNode root) {
    if (root == null) return 0;
    // 左子树空但右子树不空
    if (root.left == null && root.right != null) return 1 + minDepth(root.right);
    // 左子树不空但右子树空
    if (root.left != null && root.right == null) return 1 + minDepth(root.left);
    // 左右子树均不空
    return 1 + Math.min(minDepth(root.left), minDepth(root.right));
}
```

也可以利用层序遍历的思想，在层序遍历过程中若碰到了叶子结点，即左右孩子均为null的情况，则说明该结点就是层序遍历中碰到的第一个叶子节点，返回当前深度即为最小深度。

```java
public int minDepth(TreeNode root) {
    int minDepth = 0;
    if (root == null) return minDepth;

    Queue<TreeNode> queue = new LinkedList<>();
    queue.offer(root);
    while (!queue.isEmpty()) {
        int size = queue.size();
        minDepth++;
        while (size > 0) {
            TreeNode pointer = queue.poll();
            if (pointer.left != null) queue.offer(pointer.left);
            if (pointer.right != null) queue.offer(pointer.right);
            if (pointer.left == null && pointer.right == null) return minDepth;
            size--;
        }
    }

    return minDepth;
}
```

## 二叉树的修改与构造

### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)（简单）

递归的将每个结点的左右孩子都互换即可完成对整个树的翻转。

值得注意的是，本题可以用前序或后序遍历，但不可以使用中序遍历，因为中序遍历先将左孩子的孩子调换，再将根节点孩子调换，最后再调换右孩子时，其实调换的是原来的左孩子。

```java
public TreeNode invertTree(TreeNode root) {
    if (root == null) return null;
    TreeNode temp= root.left;
    root.left= root.right;
    root.right=temp;
    invertTree(root.left);
    invertTree(root.right);

    return root;
}
```

