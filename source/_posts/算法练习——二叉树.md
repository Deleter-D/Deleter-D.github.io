---
title: 算法练习——二叉树
tags:
  - 算法
  - 二叉树
  - 力扣
categories: [算法,力扣]
toc: true
cover: https://user-images.githubusercontent.com/56388518/193994116-bb24a164-ed0b-475f-9250-29278b14e043.png
abbrlink: 41828
date: 2022-05-03 17:18:40
---

力扣，二叉树相关练习。

<!--more-->

## 二叉树的遍历

### [144. 二叉树的前序遍历](https://leetcode-cn.com/problems/binary-tree-preorder-traversal/)（简单）

递归方式

```cpp
void preOrder(TreeNode *node, vector<int> &res) {
    if (node != nullptr) {
        res.push_back(node->val);
        preOrder(node->left, res);
        preOrder(node->right, res);
    }
}

vector<int> preorderTraversal(TreeNode *root) {
    vector<int> res;
    preOrder(root, res);
    return res;
}
```

迭代方式

```cpp
vector<int> preorderTraversal2(TreeNode *root) {
    stack<TreeNode *> st;
    vector<int> res;

    if (root == nullptr)
        return res;
    st.push(root);
    while (!st.empty()) {
        // 栈顶元素即为中间结点
        TreeNode *node = st.top();
        st.pop();
        res.push_back(node->val); // 中
        // 要使出栈顺序是中左右，则必须先将右孩子入栈
        if (node->right)
            st.push(node->right); // 右
        if (node->left)
            st.push(node->left); // 左
    }

    return res;
}
```

统一迭代方式

```cpp
vector<int> preorderTraversal3(TreeNode *root) {
    stack<TreeNode *> st;
    vector<int> res;

    if (root != nullptr)
        st.push(root);
    while (!st.empty()) {
        TreeNode *node = st.top();
        if (node != nullptr) {
            st.pop(); // 弹出当前结点避免重复操作

            if (node->right)
                st.push(node->right); // 右
            if (node->left)
                st.push(node->left); // 左
            st.push(node);           // 中
            st.push(nullptr);
        } else {
            st.pop();
            node = st.top();
            st.pop();
            res.push_back(node->val);
        }
    }

    return res;
}
```

### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)（简单）

递归方式

```cpp
void inOrder(TreeNode *node, vector<int> &res) {
    if (node != nullptr) {
        inOrder(node->left, res);
        res.push_back(node->val);
        inOrder(node->right, res);
    }
}

vector<int> inorderTraversal(TreeNode *root) {
    vector<int> res;
    inOrder(root, res);
    return res;
}
```

迭代方式

```cpp
vector<int> inorderTraversal2(TreeNode *root) {
    stack<TreeNode *> st;
    vector<int> res;

    TreeNode *cur = root;
    while (cur != nullptr || !st.empty()) {
        if (cur != nullptr) {
            // 一直遍历到树的最左下角结点
            st.push(cur);
            cur = cur->left; // 左
        } else {
            // 栈顶元素为待处理的结点
            cur = st.top();
            st.pop();
            res.push_back(cur->val); // 中
            cur = cur->right;        // 右
        }
    }

    return res;
}
```

统一迭代方式

```cpp
vector<int> inorderTraversal3(TreeNode *root) {
    stack<TreeNode *> st;
    vector<int> res;

    if (root != nullptr)
        st.push(root);
    while (!st.empty()) {
        TreeNode *node = st.top();
        if (node != nullptr) {
            st.pop(); // 弹出当前结点避免重复操作

            if (node->right)
                st.push(node->right); // 右
            st.push(node);            // 中
            st.push(nullptr); // 中间结点访问过但还未处理，加入nullptr作为标记
            if (node->left)
                st.push(node->left); // 左
        } else {      // 遇到nullptr才将下一个结点放入结果集中
            st.pop(); // 弹出空结点
            node = st.top(); // 取出栈中元素
            st.pop();
            res.push_back(node->val); // 加入结果集
        }
    }

    return res;
}
```

### [145. 二叉树的后序遍历](https://leetcode-cn.com/problems/binary-tree-postorder-traversal/)（简单）

递归方式

```cpp
void postOrder(TreeNode *node, vector<int> &res) {
    if (node != nullptr) {
        postOrder(node->left, res);
        postOrder(node->right, res);
        res.push_back(node->val);
    }
}

vector<int> postorderTraversal(TreeNode *root) {
    vector<int> res;
    postOrder(root, res);
    return res;
}
```

迭代方式

```cpp
vector<int> postorderTraversal2(TreeNode *root) {
    stack<TreeNode *> st;
    vector<int> res;

    // 大部分与前序遍历相同
    if (root == nullptr)
        return res;
    st.push(root);
    while (!st.empty()) {
        TreeNode *node = st.top();
        st.pop();
        res.push_back(node->val); // 中
        // 这里颠倒左右结点入栈顺序
        // 使遍历顺序变为中右左
        if (node->left)
            st.push(node->left); // 左
        if (node->right)
            st.push(node->right); // 右
    }

    // 反转遍历结果，变为左右中
    reverse(res.begin(), res.end());
    return res;
}
```

统一迭代方式

```cpp
vector<int> postorderTraversal3(TreeNode *root) {
    stack<TreeNode *> st;
    vector<int> res;

    if (root != nullptr)
        st.push(root);
    while (!st.empty()) {
        TreeNode *node = st.top();
        if (node != nullptr) {
            st.pop();

            st.push(node); // 中
            st.push(nullptr);
            if (node->right)
                st.push(node->right); // 右
            if (node->left)
                st.push(node->left); // 左
        } else {
            st.pop();
            node = st.top();
            st.pop();
            res.push_back(node->val);
        }
    }

    return res;
}
```

### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)（中等）

递归方式

```cpp
void order(TreeNode *node, vector<vector<int>> &res, int depth) {
    if (node == nullptr)
        return;
    if (res.size() == depth)
        res.push_back(vector<int>());
    res[depth].push_back(node->val);
    order(node->left, res, depth + 1);
    order(node->right, res, depth + 1);
}

vector<vector<int>> levelOrder(TreeNode *root) {
    vector<vector<int>> res;
    int depth = 0;
    order(root, res, depth);
    return res;
}
```

迭代方式

```cpp
vector<vector<int>> levelOrder2(TreeNode *root) {
    queue<TreeNode *> q;
    vector<vector<int>> res;

    if (root == nullptr)
        return res;
    q.push(root);
    while (!q.empty()) {
        // 记录当前队列大小，即当前层的结点数
        int size = q.size();
        vector<int> vec;
        for (int i = 0; i < size; i++) {
            TreeNode *node = q.front();
            q.pop();
            vec.push_back(node->val); // 遍历本层结点
            if (node->left)
                q.push(node->left); // 左子结点入队
            if (node->right)
                q.push(node->right); // 右子结点入队
        }
        res.push_back(vec); // 将当前层加入结果集
    }

    return res;
}
```

## 层序遍历衍生题目

### [107. 二叉树的层序遍历 II](https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii/)（中等）

正常将二叉树层序遍历，最后将遍历结果数组逆置即可。

```cpp
vector<vector<int>> levelOrderBottom(TreeNode *root) {
    vector<vector<int>> res;
    queue<TreeNode *> q;

    if (root == nullptr)
        return res;
    q.push(root);
    while (!q.empty()) {
        int size = q.size();
        vector<int> vec;
        for (int i = 0; i < size; i++) {
            TreeNode *node = q.front();
            q.pop();
            vec.push_back(node->val);
            if (node->left)
                q.push(node->left);
            if (node->right)
                q.push(node->right);
        }
        res.push_back(vec);
    }
    reverse(res.begin(), res.end());

    return res;
}
```

### [199. 二叉树的右视图](https://leetcode-cn.com/problems/binary-tree-right-side-view/)（中等）

层序遍历二叉树时，判断当前元素是否为本层最后一个元素，若是则放入结果集。

```cpp
vector<int> rightSideView(TreeNode *root) {
    vector<int> res;
    queue<TreeNode *> q;

    if (root == nullptr)
        return res;
    q.push(root);
    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            TreeNode *node = q.front();
            q.pop();
            if (node->left)
                q.push(node->left);
            if (node->right)
                q.push(node->right);
            if (i == size - 1)
                res.push_back(node->val);
        }
    }

    return res;
}
```

### [637. 二叉树的层平均值](https://leetcode-cn.com/problems/average-of-levels-in-binary-tree/)（简单）

在层序遍历的同时，计算出每层结点的和，遍历完当前层后将该层的平均值放入结果集。

```cpp
vector<double> averageOfLevels(TreeNode *root) {
    vector<double> res;
    queue<TreeNode *> q;

    if (root == nullptr)
        return res;
    q.push(root);
    while (!q.empty()) {
        int size = q.size();
        double sum = 0.0;
        for (int i = 0; i < size; i++) {
            TreeNode *node = q.front();
            q.pop();
            sum += node->val;
            if (node->left)
                q.push(node->left);
            if (node->right)
                q.push(node->right);
        }
        res.push_back(sum / size);
    }

    return res;
}
```

### [429. N 叉树的层序遍历](https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/)（中等）

与二叉树层序遍历类似，只需要在遍历当前结点的孩子结点时改为for循环，以保证遍历到该结点的每一个孩子节点。

```cpp
vector<vector<int>> levelOrder(Node *root) {
    vector<vector<int>> res;
    queue<Node *> q;

    if (root == nullptr)
        return res;
    q.push(root);
    while (!q.empty()) {
        int size = q.size();
        vector<int> vec;
        for (int i = 0; i < size; i++) {
            Node *node = q.front();
            q.pop();
            vec.push_back(node->val);
            for (Node *child : node->children) {
                q.push(child);
            }
        }
        res.push_back(vec);
    }

    return res;
}
```

### [515. 在每个树行中找最大值](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/)（中等）

层序遍历二叉树的过程中，找出每层的最大值放入结果集即可。

```cpp
vector<int> largestValues(TreeNode *root) {
    vector<int> res;
    queue<TreeNode *> q;

    if (root == nullptr)
        return res;
    q.push(root);
    while (!q.empty()) {
        int size = q.size();
        int max = INT_MIN;
        for (int i = 0; i < size; i++) {
            TreeNode *node = q.front();
            q.pop();
            if (node->val > max)
                max = node->val;
            if (node->left)
                q.push(node->left);
            if (node->right)
                q.push(node->right);
        }
        res.push_back(max);
    }

    return res;
}
```

### [116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)（中等）

层序遍历过程中，判断当前遍历结点在本层是否有后继结点，若有则将next指向它的后继结点，若没有则置为null。

```cpp
Node *connect(Node *root) {
    queue<Node *> q;

    if (root == nullptr)
        return nullptr;
    q.push(root);
    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            Node *node = q.front();
            q.pop();
            if (i < size - 1)
                node->next = q.front();
            else
                node->next = nullptr;
            if (node->left)
                q.push(node->left);
            if (node->right)
                q.push(node->right);
        }
    }

    return root;
}
```

### [117. 填充每个节点的下一个右侧节点指针 II](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node-ii/)（中等）

与[116. 填充每个节点的下一个右侧节点指针](https://leetcode-cn.com/problems/populating-next-right-pointers-in-each-node/)题没有任何差别。

```cpp
Node *connect(Node *root) {
    queue<Node *> q;

    if (root == nullptr)
        return nullptr;
    q.push(root);
    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            Node *node = q.front();
            q.pop();
            if (i < size - 1)
                node->next = q.front();
            else
                node->next = nullptr;
            if (node->left)
                q.push(node->left);
            if (node->right)
                q.push(node->right);
        }
    }

    return root;
}
```

### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)（简单）

利用层序遍历，没遍历一层深度就加一。

```cpp
int maxDepth(TreeNode *root) {
    int depth = 0;
    queue<TreeNode *> q;

    if (root == nullptr)
        return depth;
    q.push(root);
    while (!q.empty()) {
        int size = q.size();
        depth++;
        for (int i = 0; i < size; i++) {
            TreeNode *node = q.front();
            q.pop();
            if (node->left)
                q.push(node->left);
            if (node->right)
                q.push(node->right);
        }
    }

    return depth;
}
```

### [111. 二叉树的最小深度](https://leetcode-cn.com/problems/minimum-depth-of-binary-tree/)（简单）

同样利用层序遍历，当碰到的第一个叶结点所属的层数就是最小深度。

```cpp
int minDepth(TreeNode *root) {
    int depth = 0;
    queue<TreeNode *> q;

    if (root == nullptr)
        return depth;
    q.push(root);
    while (!q.empty()) {
        int size = q.size();
        depth++;
        for (int i = 0; i < size; i++) {
            TreeNode *node = q.front();
            q.pop();
            if (node->left == nullptr && node->right == nullptr)
                return depth;
            if (node->left)
                q.push(node->left);
            if (node->right)
                q.push(node->right);
        }
    }

    return depth;
}
```

## 二叉树练习

### [226. 翻转二叉树](https://leetcode-cn.com/problems/invert-binary-tree/)（简单）

递归的将每个结点的左右孩子都互换即可完成对整个树的翻转。

值得注意的是，本题可以用前序或后序遍历，但不可以使用中序遍历，因为中序遍历先将左孩子的孩子调换，再将根节点孩子调换，最后再调换右孩子时，其实调换的是原来的左孩子。

```cpp
TreeNode *invertTree(TreeNode *root) {
    if (root == nullptr)
        return root;
    swap(root->left, root->right);
    invertTree(root->left);
    invertTree(root->right);
    return root;
}
```

也可以用迭代法来解决。

```cpp
TreeNode *invertTree2(TreeNode *root) {
    if (root == nullptr)
        return root;
    stack<TreeNode *> st;
    st.push(root);
    while (!st.empty()) {
        TreeNode *node = st.top();
        st.pop();
        swap(node->left, node->right);
        if (node->right)
            st.push(node->right);
        if (node->left)
            st.push(node->left);
    }

    return root;
}
```

### [101. 对称二叉树](https://leetcode.cn/problems/symmetric-tree/)（简单）

本题的关键是想明白要比较的是什么，对称的二叉树本质上是根结点的左子树和右子树拥有相互翻转关系。所以要比较的是两棵树，在递归遍历的过程中要同时遍历两颗树。左子树需要通过左右中的顺序来遍历，右子树需要通过右左中的顺序来遍历，都可以算是后序遍历。

```cpp
bool compare(TreeNode *left, TreeNode *right) {
    // 首先排除存在空结点的情况
    if (left == nullptr && right != nullptr) // 左空右不空
        return false;
    else if (left != nullptr && right == nullptr) // 左不空右空
        return false;
    else if (left == nullptr && right == nullptr) // 左右都空
        return true;
    // 再排除数值不同的情况
    else if (left->val != right->val) // 左右都不空，但值不相等
        return false;

    // 此时剩下的就是左右结点都不空，且数值相同的情况
    bool outside = compare(left->left, right->right); // 左子树：左、右子树：右
    bool inside = compare(left->right, right->left); // 左子树：右、右子树：左
    return outside && inside; // 左子树：中、右子树：中
}

bool isSymmetric(TreeNode *root) { return compare(root->left, root->right); }
```

也可以用迭代法解决，但迭代方式和前中后序遍历的任何一种都不同。在迭代过程中要将两个待比较的结点入队，然后从队列中成对的取出进行比较。

```cpp
bool isSymmetric2(TreeNode *root) {
    queue<TreeNode *> q;
    q.push(root->left);  // 左子树头结点入队
    q.push(root->right); // 右子树头结点入队

    while (!q.empty()) {
        TreeNode *leftNode = q.front();
        q.pop();
        TreeNode *rightNode = q.front();
        q.pop();
        // 左右子树都空
        if (leftNode == nullptr && rightNode == nullptr)
            continue;

        // 左右子树有一个不空，或都不为空但值不相等
        if (leftNode == nullptr || rightNode == nullptr ||
            leftNode->val != rightNode->val)
            return false;

        q.push(leftNode->left);   // 左结点的左孩子
        q.push(rightNode->right); // 右结点的右孩子
        q.push(leftNode->right);  // 左结点的右孩子
        q.push(rightNode->left);  // 右结点的左孩子
    }

    return true;
}
```

### [222. 完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)（简单）

本题用遍历的方法很简单就可以解决，但由于完全二叉树的特性，可以使用更低的复杂度来解决。

完全二叉树有两种情况，一种是满二叉树，一种是最后一层叶子结点未满。对于满二叉树，结点个数就是$2^n-1$，$n$为树的深度。对于未满的二叉树，分别递归左孩子和右孩子，递归到一定深度一定会有满二叉树，可以用满二叉树的公式来计算。

```cpp
int countNodes(TreeNode *root) {
    if (root == nullptr)
        return 0;
    TreeNode *left = root->left;
    TreeNode *right = root->right;
    int leftDepth = 0, rightDepth = 0;
    while (left != nullptr) { // 求左子树深度
        left = left->left;
        leftDepth++;
    }
    while (right != nullptr) { // 求右子树深度
        right = right->right;
        rightDepth++;
    }
    if (leftDepth == rightDepth) // 满二叉树的情况
        return (2 << leftDepth) - 1;
    // 叶子结点未满的情况
    return countNodes(root->left) + countNodes(root->right) + 1;
}
```

### [110. 平衡二叉树](https://leetcode.cn/problems/balanced-binary-tree/)（简单）

判断是否为平衡二叉树只需要判断左右子树的高度差是否不大于1，所以需要一个函数来求得树的高度。求高度可以用递归的方式，一层一层求下去。递归函数的返回值自然是树的高度。终止条件就是遇到空结点，空结点的高度为0。单层递归的主要逻辑就是判断左右子树高度差，如果此时左右子树有一个不是平衡二叉树，那么就可以直接返回-1作为标记，不必再返回高度了。若左右子树高度差不大于1，则返回较高子树的高度+1，加1将当前结点的高度也计算进去。

```cpp
int getHeight(TreeNode *node) {
    if (node == nullptr)
        return 0;

    // 左右子树任何一个不是平衡二叉树就直接返回-1
    int leftHeight = getHeight(node->left);
    if (leftHeight == -1)
        return -1;
    int rightHeight = getHeight(node->right);
    if (rightHeight == -1)
        return -1;

    // 左右子树高度差大于1则返回-1
    // 不大于1则返回较高子树高度+1
    return abs(leftHeight - rightHeight) > 1 ? -1 : 1 + max(leftHeight, rightHeight);
}

bool isBalanced(TreeNode *root) { return getHeight(root) == -1 ? false : true; }
```

### [257. 二叉树的所有路径](https://leetcode.cn/problems/binary-tree-paths/)（简单）

本题强烈的体现了回溯的思想，需要一个递归的函数来寻找路径。递归终止条件是当前结点为叶子结点，此时就需要生成根节点到这个叶结点的路径并存入结果集中。单层递归的逻辑就是访问当前结点的左孩子和右孩子，访问完之后，也就是递归函数返回之后，需要将上一个访问的结点从路径中去除，这就是回溯的过程。

```cpp
void traversal(TreeNode *node, vector<int> &path, vector<string> &res) {
    path.push_back(node->val); // 当前结点的值存入path数组
    // 碰到叶子结点
    if (node->left == nullptr && node->right == nullptr) {
        string sPath;
        for (int i = 0; i < path.size() - 1; i++) {
            sPath += to_string(path[i]);
            sPath += "->";
        }
        sPath += to_string(path[path.size() - 1]);
        res.push_back(sPath);
        return;
    }
    // 处理左子树
    if (node->left != nullptr) {
        traversal(node->left, path, res);
        path.pop_back(); // 回溯
    }
    // 处理右子树
    if (node->right != nullptr) {
        traversal(node->right, path, res);
        path.pop_back(); // 回溯
    }
}

vector<string> binaryTreePaths(TreeNode *root) {
    vector<string> res;
    vector<int> path;
    if (root == nullptr)
        return res;
    traversal(root, path, res);
    return res;
}
```

