---
title: 算法练习——数组
tags:
  - 算法
  - 数组
  - 力扣
categories: [算法,力扣]
toc: true
abbrlink: 56699
date: 2022-03-18 16:39:33
---

力扣，数组相关练习。

<!--more-->

## [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)（简单）

二分查找中，最需要注意的一点就是循环过程中范围的变化。要将范围区间确定下来，左闭右闭区间或左闭右开区间都可以，但要保证每次循环确定区间的一致性。

以左闭右闭区间为例，每次寻找的范围必须是`[begin, end]`，此时要考虑`begin == end`时有没有意义。显然，对于左闭右闭区间，`begin == end`时，当前区间内还有一个元素，所以是有意义的。故可以得出循环条件应该保持`begin <= end`。

更新区间的时候要注意，当目标值小于中间位置元素时，要将`end`更新为`middle - 1`，因为是右闭区间，所以不能让更新后的区间右侧包含刚才已经比较过的元素。同理，当目标值大于中间位置元素时，要将`begin`更新为`middle + 1`。故可以得出更新的条件为`begin = middle + 1`与`end = middle - 1`。

其中的`middle`可以通过`(end - begin) / 2 + begin`得到，这是随机访问数据结构中常用的确定中点的方式。

```c++
int search(vector<int> &nums, int target)
{
    int begin = 0, end = nums.size() - 1;
    while (begin <= end)
    {
        int middle = (end - begin) / 2 + begin;
        if (target == nums[middle])
            return middle;
        else if (target < nums[middle])
            end = middle - 1;
        else
            begin = middle + 1;
    }
    return -1;
}
```

而以左闭右开区间为例，每次寻找的范围是`[begin, end)`。这种情况下，当`begin == end`时区间是没有意义的，所以循环条件应为`begin < end`。

更新区间时，也要保证更新后的区间不包含之前比较过的元素，同时保证区间有意义。当目标值小于中间位置元素时，更新`end = middle`，由于是右开区间，所以更新后的`end`位置元素不会参与比较。当目标值大于中间位置元素时，更新`begin = middle + 1`，因为更新之前的`middle`位置元素已经被比较过了。

```c++
int search(vector<int> &nums, int target)
{
    int begin = 0, end = nums.size();
    while (begin < end)
    {
        int middle = (end - begin) / 2 + begin;
        if (target == nums[middle])
            return middle;
        else if (target < nums[middle])
            end = middle;
        else
            begin = middle + 1;
    }
    return -1;
}
```

## [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)（简单）

本题的核心思想就是用后面的元素覆盖前面等于目标值的元素。

暴力法是容易想到的，使用两层for循环，第一层遍历整个数组，第二层更新数组。注意在更新数组后，要将当前的下标前移一位，因为后续的所以元素都向前移动了一位。同时注意循环次数的控制，当新数组长度减少后，相应地，循环次数也应该减少。

```c++
int removeElement(vector<int> &nums, int val)
{
    int size = nums.size();
    for (int i = 0; i < size; ++i) // 利用size而不是nums.size()控制循环次数
    {
        if (nums[i] == val)
        {
            for (int j = i + 1; j < size; j++)
                nums[j - 1] = nums[j];
            --i; // 注意此处的下标前移
            --size; // 每次遇到满足条件的元素都要将最终返回的数组长度减1
        }
    }
    return size;
}
```

更巧妙的方法是双指针法，也叫快慢指针法。核心思想是要找到快慢指针分别代表的意义。

- 快指针将寻找不等于目标值的元素，也即新数组的元素。
- 慢指针指向待更新元素。

```c++
int removeElement(vector<int> &nums, int val)
{
    int slowIndex = 0;
    for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++)
        if (nums[fastIndex] != val) // 快指针碰到不满足条件的值
            nums[slowIndex++] = nums[fastIndex]; // 将该元素覆盖到慢指针指向的待更新，并将慢指针向前移动
    return slowIndex; // 最终慢指针指向的就是数组尾后位置
}
```

## [977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)（简单）

本题同样可以采用双指针的方法，但需要转变一下思路。一开始的时候容易想到先找到绝对值最小的元素，然后两个指针向两边移动。但可以反过来想一想，双指针从数组的两端开始往中间移动，自然的就能依次找到绝对值从大到小的元素。

故使用两个指针，一个指向数组首元素，一个指向数组尾元素。再定义一个与原数组大小相等的结果数组，由于要求结果是非降序排列，故从结果数组的末尾开始，依次向前放置元素的平方。

```c++
vector<int> sortedSquares(vector<int> &nums)
{
    int k = nums.size() - 1;
    vector<int> res(nums.size(), 0);
    int i = 0, j = nums.size() - 1;
    while (i <= j)
    {
        if (nums[i] * nums[i] < nums[j] * nums[j])
        {
            res[k--] = nums[j] * nums[j];
            --j;
        }
        else
        {
            res[k--] = nums[i] * nums[i];
            ++i;
        }
    }
    return res;
}
```

## [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)（中等）

该题利用滑动窗口解决，即设定两个指针`left`和`right`，当窗口内的元素和小于`target`时，将`right`往右移动扩大窗口，继续判断，当窗口内元素和大于等于`target`时，则说明找到了一个答案，此时记录下窗口大小，然后将`left`向右移动，即将窗口的左侧缩小一个元素，若此时不满足，就继续右移`right`，并继续循环判断。

```cpp
int minSubArrayLen(int target, vector<int> &nums) {
    int slow = 0, fast = 0;
    int sum = 0;
    int minlen = INT32_MAX;
    for (; fast < nums.size(); fast++) {
        sum += nums[fast]; // 滑动窗口不断扩大，并将加入窗口的元素累加到sum中
        while (sum >= target) { // 当窗口中的元素和满足条件后
            if ((fast - slow + 1) < minlen)
                minlen = fast - slow + 1; // 记录当前滑动窗口的大小
            sum -= nums[slow]; // 将滑动窗口的左侧缩小一个元素
            slow++;
        }
    }

    if (minlen == INT32_MAX)
        return 0;
    else
        return minlen;
}
```

## [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)（中等）

该题的解法就是模拟旋转的过程，最重要的一点就是保持循环过程中，所控制的区间不变。这里采取左闭右开的模式比较合理，即每一行或每一列的最后一个元素，交给拐弯后的循环去控制。

```java
vector<vector<int>> generateMatrix(int n) {
    int start_row = 0, start_col = 0; // 记录起始行和列
    vector<vector<int>> res(n, vector<int>(n, 0));
    int loop = n / 2; // 计算所需的圈数
    int offset = 1; // 控制每次遍历的长度，即末端已经处理过的数据宽度
    int count = 1; // 用于计数和赋值
    int i, j;
    while (loop--) {
        for (j = start_col; j < n - offset; j++) { // 向右移动
            res[start_row][j] = count++;
        }
        for (i = start_row; i < n - offset; i++) { // 向下移动
            res[i][j] = count++;
        }
        for (; j > start_col; j--) { // 向左移动
            res[i][j] = count++;
        }
        for (; i > start_row; i--) { // 向上移动
            res[i][j] = count++;
        }
        start_row++; // 起始行加一
        start_col++; // 起始列加一
        offset++; // 已经处理过的数据宽度加一
    }

    if (n % 2) { // 若n为奇数，则存在独立的中心点
        int mid = n / 2;
        res[mid][mid] = count; // 单独赋值
    }

    return res;
}

```

