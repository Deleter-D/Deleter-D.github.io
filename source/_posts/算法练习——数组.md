---
title: 算法练习——数组
tags:
  - 算法
  - 数组
  - 力扣
categories: [算法,力扣]
toc: true
cover: https://user-images.githubusercontent.com/56388518/193993740-0a3a443f-130a-48bd-8535-33addadc536d.png
abbrlink: 56699
date: 2022-03-18 16:39:33
---

力扣，数组相关练习。

<!--more-->

# 数组

## [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)（简单）

二分查找中，最需要注意的一点就是循环过程中范围的变化。要将范围区间确定下来，左闭右闭区间或左闭右开区间都可以，但要保证每次循环确定区间的一致性。

以左闭右闭区间为例，每次寻找的范围必须是`[begin, end]`，此时要考虑`begin == end`时有没有意义。显然，对于左闭右闭区间，`begin == end`时，当前区间内还有一个元素，所以是有意义的。故可以得出循环条件应该保持`begin <= end`。

更新区间的时候要注意，当目标值小于中间位置元素时，要将`end`更新为`middle - 1`，因为是右闭区间，所以不能让更新后的区间右侧包含刚才已经比较过的元素。同理，当目标值大于中间位置元素时，要将`begin`更新为`middle + 1`。故可以得出更新的条件为`begin = middle + 1`与`end = middle - 1`。

其中的`middle`可以通过`(end - begin) / 2 + begin`得到，这是随机访问数据结构中常用的确定中点的方式。

```c++
int search(vector<int> &nums, int target)
{
    int begin = 0, end = nums.size() - 1;
    while (begin <= end)
    {
        int middle = (end - begin) / 2 + begin;
        if (target == nums[middle])
            return middle;
        else if (target < nums[middle])
            end = middle - 1;
        else
            begin = middle + 1;
    }
    return -1;
}
```

而以左闭右开区间为例，每次寻找的范围是`[begin, end)`。这种情况下，当`begin == end`时区间是没有意义的，所以循环条件应为`begin < end`。

更新区间时，也要保证更新后的区间不包含之前比较过的元素，同时保证区间有意义。当目标值小于中间位置元素时，更新`end = middle`，由于是右开区间，所以更新后的`end`位置元素不会参与比较。当目标值大于中间位置元素时，更新`begin = middle + 1`，因为更新之前的`middle`位置元素已经被比较过了。

```c++
int search(vector<int> &nums, int target)
{
    int begin = 0, end = nums.size();
    while (begin < end)
    {
        int middle = (end - begin) / 2 + begin;
        if (target == nums[middle])
            return middle;
        else if (target < nums[middle])
            end = middle;
        else
            begin = middle + 1;
    }
    return -1;
}
```

## [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)（简单）

本题的核心思想就是用后面的元素覆盖前面等于目标值的元素。

暴力法是容易想到的，使用两层for循环，第一层遍历整个数组，第二层更新数组。注意在更新数组后，要将当前的下标前移一位，因为后续的所以元素都向前移动了一位。同时注意循环次数的控制，当新数组长度减少后，相应地，循环次数也应该减少。

```c++
int removeElement(vector<int> &nums, int val)
{
    int size = nums.size();
    for (int i = 0; i < size; ++i) // 利用size而不是nums.size()控制循环次数
    {
        if (nums[i] == val)
        {
            for (int j = i + 1; j < size; j++)
                nums[j - 1] = nums[j];
            --i; // 注意此处的下标前移
            --size; // 每次遇到满足条件的元素都要将最终返回的数组长度减1
        }
    }
    return size;
}
```

更巧妙的方法是双指针法，也叫快慢指针法。核心思想是要找到快慢指针分别代表的意义。

- 快指针将寻找不等于目标值的元素，也即新数组的元素。
- 慢指针指向待更新元素。

```c++
int removeElement(vector<int> &nums, int val)
{
    int slowIndex = 0;
    for (int fastIndex = 0; fastIndex < nums.size(); fastIndex++)
        if (nums[fastIndex] != val) // 快指针碰到不满足条件的值
            nums[slowIndex++] = nums[fastIndex]; // 将该元素覆盖到慢指针指向的待更新，并将慢指针向前移动
    return slowIndex; // 最终慢指针指向的就是数组尾后位置
}
```

## [977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)（简单）

本题同样可以采用双指针的方法，但需要转变一下思路。一开始的时候容易想到先找到绝对值最小的元素，然后两个指针向两边移动。但可以反过来想一想，双指针从数组的两端开始往中间移动，自然的就能依次找到绝对值从大到小的元素。

故使用两个指针，一个指向数组首元素，一个指向数组尾元素。再定义一个与原数组大小相等的结果数组，由于要求结果是非降序排列，故从结果数组的末尾开始，依次向前放置元素的平方。

```c++
vector<int> sortedSquares(vector<int> &nums)
{
    int k = nums.size() - 1;
    vector<int> res(nums.size(), 0);
    int i = 0, j = nums.size() - 1;
    while (i <= j)
    {
        if (nums[i] * nums[i] < nums[j] * nums[j])
        {
            res[k--] = nums[j] * nums[j];
            --j;
        }
        else
        {
            res[k--] = nums[i] * nums[i];
            ++i;
        }
    }
    return res;
}
```

## [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)（中等）

该题利用滑动窗口解决，即设定两个指针`left`和`right`，当窗口内的元素和小于`target`时，将`right`往右移动扩大窗口，继续判断，当窗口内元素和大于等于`target`时，则说明找到了一个答案，此时记录下窗口大小，然后将`left`向右移动，即将窗口的左侧缩小一个元素，若此时不满足，就继续右移`right`，并继续循环判断。

```java
public int minSubArrayLen(int target, int[] nums) {
    int left = 0;
    int sum = 0;
    int result = Integer.MAX_VALUE;
    for (int right = 0; right < nums.length; right++) {
        sum += nums[right];// 滑动窗口不断扩大，并将加入窗口的元素累加到sum中
        while (sum >= target) {// 当窗口中的元素和满足条件后
            result = Math.min(result, right - left + 1);// 记录当前滑动窗口的大小
            sum -= nums[left++];// 将滑动窗口的左侧缩小一个元素
        }
    }
    return result == Integer.MAX_VALUE ? 0 : result;
}
```

## [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)（中等）

可以按分治法理解，每一圈为一个子问题，详情见算法笔记——分治_数字旋转方阵

```java
public int[][] generateMatrix(int n) {
    int[][] result = new int[n][n];
    Full(result, 0, 0, n, 1);

    return result;
}

public void Full(int[][] result, int tr, int tc, int n, int count) {
    if (n == 0) return;
    if (n == 1) {
        result[tr][tc] = count;
        return;
    }
    int i = tr, j = tc;
    for (; j < n + tc; j++) {// 向右
        result[i][j] = count++;
    }
    j--;
    for (i++; i < n+tr; i++) {// 向下
        result[i][j] = count++;
    }
    i--;
    for (j--; j >= tc; j--) {// 向左
        result[i][j] = count++;
    }
    j++;
    for (i--; i > tr; i--) {// 向上
        result[i][j] = count++;
    }
    Full(result, tr + 1, tc + 1, n - 2, count);
}
```

