---
title: 算法练习——数组
tags:
  - 算法
  - 数组
  - 力扣
categories: 算法
cover: https://user-images.githubusercontent.com/56388518/193993740-0a3a443f-130a-48bd-8535-33addadc536d.png
abbrlink: 56699
date: 2022-03-18 16:39:33
---

# 数组

## [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)（简单）

递归

```java
public int search(int[] nums, int target) {
    if (nums.length == 1){
        if (nums[0]==target)
            return 0;
        else 
            return -1;
    }
    return BinarySearch(nums, 0, nums.length-1, target);
}

public int BinarySearch(int[] nums, int low, int high, int target) {
    if (low > high)
        return -1;
    int mid = (high - low) / 2 + low;
    if (nums[mid] == target)
        return mid;
    else if (nums[mid] < target)
        return BinarySearch(nums, mid + 1, high, target);
    else
        return BinarySearch(nums, low, mid - 1, target);
}
```

非递归

```java
public int search(int[] nums, int target) {
    if (nums.length == 1) {
        if (nums[0] == target)
            return 0;
        else
            return -1;
    }
    int low = 0, high = nums.length - 1;
    while (low <= high) {
        int mid = (high - low) / 2 + low;
        if (nums[mid] == target)
            return mid;
        else if (nums[mid] < target)
            low = mid + 1;
        else
            high = mid - 1;
    }
    return -1;
}
```

## [27. 移除元素](https://leetcode-cn.com/problems/remove-element/)（简单）

设置两个指针（相向双指针），`i`从头开始往右运动，`j`从末尾开始往左运动

- 当`nums[i] == val`时，将`nums[j]`拿到`i`的位置覆盖，并且`j--`
- 当`nums[i] != val`时，`i++`

直到`i`与`j`相撞，再判断`i == j`时的情况

- 若`nums[i] == val`，则`i--`，相当于将`i`当前指向的元素除去
- 若`nums[i] != val`，则直接跳出循环

此时`i`指向的就是最后一个复合要求的元素，`i`之前的元素经过与后面元素的替换已经全部满足要求，故返回`i+1`，即数组长度

```java
public int removeElement(int[] nums, int val) {
    int i = 0, j = nums.length - 1;
    while (i <= j) {
        if (i == j) {
            if (nums[i] == val)
                i--;
            break;
        }
        if (nums[i] == val) {
            nums[i] = nums[j];
            j--;
        } else {
            i++;
        }
    }
    return i + 1;
}
```

## [977. 有序数组的平方](https://leetcode-cn.com/problems/squares-of-a-sorted-array/)（简单）

直接利用相向双指针，一个从末尾往前，一个从头往后，比较两指针指向的元素，绝对值大者优先将其平方放入结果数组

注意：由于要求结果非降序排列，故结果数组从最后一个位置开始，依次往前放置

```java
public int[] sortedSquares(int[] nums) {
    int low = 0, high = nums.length - 1;
    int[] result = new int[nums.length];
    for (int i = result.length - 1; i >= 0; i--) {
        if (Math.abs(nums[low]) > Math.abs(nums[high])) {
            result[i] = nums[low] * nums[low];
            low++;
        } else {
            result[i] = nums[high] * nums[high];
            high--;
        }
    }

    return result;
}
```

## [209. 长度最小的子数组](https://leetcode-cn.com/problems/minimum-size-subarray-sum/)（中等）

该题利用滑动窗口解决，即设定两个指针`left`和`right`，当窗口内的元素和小于`target`时，将`right`往右移动扩大窗口，继续判断，当窗口内元素和大于等于`target`时，则说明找到了一个答案，此时记录下窗口大小，然后将`left`向右移动，即将窗口的左侧缩小一个元素，若此时不满足，就继续右移`right`，并继续循环判断。

```java
public int minSubArrayLen(int target, int[] nums) {
    int left = 0;
    int sum = 0;
    int result = Integer.MAX_VALUE;
    for (int right = 0; right < nums.length; right++) {
        sum += nums[right];// 滑动窗口不断扩大，并将加入窗口的元素累加到sum中
        while (sum >= target) {// 当窗口中的元素和满足条件后
            result = Math.min(result, right - left + 1);// 记录当前滑动窗口的大小
            sum -= nums[left++];// 将滑动窗口的左侧缩小一个元素
        }
    }
    return result == Integer.MAX_VALUE ? 0 : result;
}
```

## [59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)（中等）

可以按分治法理解，每一圈为一个子问题，详情见算法笔记——分治_数字旋转方阵

```java
public int[][] generateMatrix(int n) {
    int[][] result = new int[n][n];
    Full(result, 0, 0, n, 1);

    return result;
}

public void Full(int[][] result, int tr, int tc, int n, int count) {
    if (n == 0) return;
    if (n == 1) {
        result[tr][tc] = count;
        return;
    }
    int i = tr, j = tc;
    for (; j < n + tc; j++) {// 向右
        result[i][j] = count++;
    }
    j--;
    for (i++; i < n+tr; i++) {// 向下
        result[i][j] = count++;
    }
    i--;
    for (j--; j >= tc; j--) {// 向左
        result[i][j] = count++;
    }
    j++;
    for (i--; i > tr; i--) {// 向上
        result[i][j] = count++;
    }
    Full(result, tr + 1, tc + 1, n - 2, count);
}
```

