---
title: 设计模式——代理模式
tags:
  - 代理模式
  - 设计模式
categories: 设计模式
cover: >-
  https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fnewyx-img.hellonitrack.com%2Fnewspic%2Fimage%2F201506%2F17%2F81731c54d6.jpg&refer=http%3A%2F%2Fnewyx-img.hellonitrack.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1658474759&t=c3f4f9159ebfebdaa27ada7c02651432
abbrlink: 28022
date: 2022-06-22 15:24:11
---

# 代理模式

在某些情况下，一个客户不想或不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用。

## 角色

1. Subject（抽象主题角色）

   抽象主题角色声明了真实主题和代理主题的共同接口，在任何使用真实主题的地方都可以使用代理主题。客户端需要针对抽象主题角色进行编程。

2. Proxy（代理主题角色）

   代理主题角色包含对真实主题的引用，在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题。同时可以控制真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。代理主题角色往往在客户端调用真实主题操作之前或之后需要执行其他操作，并不仅仅是单纯的调用真实主题对象中的操作。

3. Real Subject（真实主题角色）

   真实主题角色定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作。

## 实例

定义一个抽象主题角色

```java
public interface Image {
    void display();
}
```

定义真实主题角色

```java
public class RealImage implements Image {
    private String fileName;

    public RealImage(String fileName) {
        this.fileName = fileName;
        loadFromDisk(fileName);
    }

    @Override
    public void display() {
        System.out.println("Displaying " + fileName + ".");
    }

    public void loadFromDisk(String fileName) {
        System.out.println("Loading " + fileName + "from disk.");
    }
}
```

定义代理主题角色

```java
public class ProxyImage implements Image {
    private RealImage realImage;
    private String fileName;

    public ProxyImage(String fileName) {
        this.fileName = fileName;
    }

    @Override
    public void display() {
        if (realImage == null) {
            realImage = new RealImage(fileName);
        }
        realImage.display();
    }
}
```

客户端测试类

```java
public class Client {
    public static void main(String[] args) {
        // 此时还没有从硬盘读取真正的图片
        ProxyImage proxyImage = new ProxyImage("test_image.jpg");
        // 只有调用真实图片对象的方法时，才由代理图片创建真实图片对象，并调用该方法
        proxyImage.display();
        System.out.println("Display it again.");
        // 再次调用时无需从硬盘中重复读取
        proxyImage.display();
    }
}
```

运行结果为

```
Loading test_image.jpgfrom disk.
Displaying test_image.jpg.
Display it again.
Displaying test_image.jpg.
```

## 代理模式的种类

### 远程代理

远程代理可以作为另一个JVM上对象的本地代表。调用代理的方法，会被代理利用网络转发到远程执行，并且结果会通过网络返回给代理，再由代理将结果转给客户。

### 虚拟代理

虚拟代理作为创建开销大的对象的代表，经常会直到我们真正需要一个对象的时候才创建它。当对象在创建前和创建中时，由虚拟代理地来扮演对象的替身。对象创建后，代理就会将请求直接委托给对象。

### 保护代理（Protect or Access）

对真实对象的功能做一些访问限制，在代理层做身份验证，通过了验证，才调用真实的主体对象的相应方法。

### 智能引用代理（Smart Reference）

当调用真实的对象时，代理处理另外一些事情。比如，在访问一个实际对象前，检查是否已经锁定它，以确保其他对象不能改变它。也就是在访问一个对象时附加的 一些内务处理。

> Windows系统中的快捷方式、Spring框架中的AOP均利用了代理模式。

## 模式优缺点

### 优点

- 代理模式能够协调被调用者和调用者，在一定程度上降低了系统的耦合度；
- 远程代理使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求；
- 虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度；
- 保护代理可以控制对真实对象的使用权限。

### 缺点

- 由于在客户端和真是主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢；
- 实现代理模式需要额外的工作，有些代理模式的实现非常复杂。
