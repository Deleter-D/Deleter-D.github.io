---
title: 算法练习——栈与队列
tags:
  - 算法
  - 栈
  - 队列
  - 力扣
categories: 算法
cover: https://user-images.githubusercontent.com/56388518/193994025-4a246ec8-54c2-4074-b1bf-2e718ec4b0b3.png
abbrlink: 3160
date: 2022-04-28 17:06:25
---

# 栈与队列

## [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)（简单）

```java
Stack<Integer> stack1;
Stack<Integer> stack2;

public MyQueue() {
    stack1 = new Stack<>();
    stack2 = new Stack<>();
}

public void push(int x) {
    stack1.push(x);
}

public int pop() {
    while (!stack1.empty()) {
        stack2.push(stack1.pop());
    }
    Integer res = stack2.pop();
    while (!stack2.empty()) {
        stack1.push(stack2.pop());
    }

    return res;
}

public int peek() {
    while (!stack1.empty()) {
        stack2.push(stack1.pop());
    }
    Integer res = stack2.peek();
    while (!stack2.empty()) {
        stack1.push(stack2.pop());
    }

    return res;
}

public boolean empty() {
    return stack1.empty();
}
```

## [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)（简单）

```java
Queue<Integer> queue1;
Queue<Integer> queue2;

public MyStack() {
    queue1 = new LinkedList<>();
    queue2 = new LinkedList<>();
}

public void push(int x) {
    queue2.offer(x);
    while (!queue1.isEmpty()) {
        queue2.offer(queue1.poll());
    }
    Queue<Integer> temp;
    temp = queue1;
    queue1 = queue2;
    queue2 = temp;
}

public int pop() {
    return queue1.poll();
}

public int top() {
    return queue1.peek();
}

public boolean empty() {
    return queue1.isEmpty();
}
```

## [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)（简单）

```java
public boolean isValid(String s) {
    Stack<Character> stack = new Stack<>();
    char[] chars = s.toCharArray();
    for (Character item : chars) {
        try {
            if (item == '(' || item == '{' || item == '[') {
                stack.push(item);
            } else {
                if (item == ')') {
                    if (stack.peek() == '(') stack.pop();
                    else return false;
                } else if (item == '}') {
                    if (stack.peek() == '{') stack.pop();
                    else return false;
                } else {
                    if (stack.peek() == '[') stack.pop();
                    else return false;
                }
            }
        }catch (Exception e){
            return false;
        }

    }
    if (stack.isEmpty()) return true;
    else return false;
}
```

## [1047. 删除字符串中的所有相邻重复项](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)（简单）

```java
public String removeDuplicates(String s) {
    Stack<Character> stack = new Stack<>();
    char[] chars = s.toCharArray();
    for (Character item : chars) {
        if (stack.isEmpty()) {
            stack.push(item);
        } else {
            if (stack.peek() == item) stack.pop();
            else stack.push(item);
        }
    }
    StringBuilder builder = new StringBuilder();
    while (!stack.isEmpty()) {
        builder.append(stack.pop());
    }
    return builder.reverse().toString();
}
```

## [150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)（中等）

```java
public int evalRPN(String[] tokens) {
    Stack<String> number_stack = new Stack<>();
    for (String item : tokens) {
        // 注意：LeetCode内置jdk不可以使用 == 判断字符串相等
        if (item.equals("+") || item.equals("-") || item.equals("*") || item.equals("/")) {
            int num2 = Integer.parseInt(number_stack.pop());
            int num1 = Integer.parseInt(number_stack.pop());
            if (item.equals("+")) number_stack.push(String.valueOf(num1 + num2));
            if (item.equals("-")) number_stack.push(String.valueOf(num1 - num2));
            if (item.equals("*")) number_stack.push(String.valueOf(num1 * num2));
            if (item.equals("/")) number_stack.push(String.valueOf(num1 / num2));
        } else number_stack.push(item);
    }

    return Integer.parseInt(number_stack.pop());
}
```

## [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)（困难）

利用双端队列实现一个**单调队列**，该单调队列的操作满足如下要求：

- 出队：若窗口移除的元素等于单调队列的出口元素则出队，否则不操作
- 入队：若待入队元素大于单调队列入口处元素，则将队列入口的元素弹出，直到待入队元素小于队列入口元素

保持这样的队则操作单调队列，则可以保证单调队列的队头元素即为当前窗口中的最大元素

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int[] res = new int[nums.length - k + 1];
        int num = 0;
        MyQueue myQueue = new MyQueue();
        for (int i = 0; i < k; i++) {
            myQueue.myAdd(nums[i]);
        }
        res[num++] = myQueue.myPeek();
        for (int i = k; i < nums.length; i++) {
            myQueue.myPoll(nums[i - k]);
            myQueue.myAdd(nums[i]);
            res[num++] = myQueue.myPeek();
        }
        return res;
    }
}

class MyQueue {
    Deque<Integer> deque = new LinkedList<>();

    // 元素出队时，比较待出队元素是否和队列出口的元素相等，若相等则说明该元素还未被弹出，故出队
    // 若不相等则说明该元素在进行add操作时就被弹出，则不操作
    public void myPoll(int value) {
        if (!deque.isEmpty() && value == deque.peek()) {
            deque.poll();
        }
    }

    // 元素入队时，若待入队元素大于队列入口的元素，则将入口处元素弹出，直到待入队元素小于入口处元素为止
    // 这样可以保证队列是单调的，且仅需维护可能为窗口内最大值的元素即可
    public void myAdd(int value) {
        while (!deque.isEmpty() && value > deque.getLast()) {
            deque.removeLast();
        }
        deque.add(value);
    }

    public int myPeek() {
        return deque.peek();
    }
}
```

## [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)（中等）

本题涉及到一种特殊的数据结构——优先级队列

优先级队列在操作上与队列几乎一致，队尾入队，队头出队，但实质上是一个堆

Java中的优先级队列在默认构造方法下：

- 对于数字类型的优先级队列，默认数字越小优先级越高
- 对于字符串类型的优先级对列，默认安照ASCII码位置，位置越小优先级越高

```java
public int[] topKFrequent(int[] nums, int k) {
    int[] res = new int[k];
    HashMap<Integer, Integer> map = new HashMap<>();
    for (int num : nums) {
        map.put(num, map.getOrDefault(num, 0) + 1);
    }
    // 将map转化为set
    Set<Map.Entry<Integer, Integer>> entries = map.entrySet();
    // 根据map的value值，即每个元素出现的频率升序排列，相当于小顶堆
    // 优先级队列会自动将队列中的元素进行排列，默认使用大顶堆，所以需要手动传入比较器
    PriorityQueue<Map.Entry<Integer, Integer>> queue = new PriorityQueue<>((o1, o2) -> o1.getValue() - o2.getValue());
    for (Map.Entry<Integer, Integer> entry : entries) {
        // 依次将所有元素放入优先级队列中
        queue.offer(entry);
        // 若队列大小大于k则需要出队，即抛弃小顶堆的堆顶元素
        if (queue.size() > k) {
            queue.poll();
        }
    }
    for (int i = k - 1; i >= 0; i--) {
        res[i] = queue.poll().getKey();
    }

    return res;
}
```

