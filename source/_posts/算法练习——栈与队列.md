---
title: 算法练习——栈与队列
tags:
  - 算法
  - 栈
  - 队列
  - 力扣
categories: [算法,力扣]
toc: true
cover: https://user-images.githubusercontent.com/56388518/193994025-4a246ec8-54c2-4074-b1bf-2e718ec4b0b3.png
abbrlink: 3160
date: 2022-04-28 17:06:25
---

力扣，栈与队列相关练习。

<!--more-->

## [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)（简单）

本题比较简单，使用两个栈，一个作为存放数据的栈，另一个作为临时中转的栈。

```cpp
class MyQueue {
  public:
    MyQueue() {}

    void push(int x) { stack1.push(x); }

    int pop() {
        while (!stack1.empty()) { // 数据转移到中转栈
            stack2.push(stack1.top());
            stack1.pop();
        }
        int res = stack2.top();   // 获取队头数据
        stack2.pop();             // 该数据出队
        while (!stack2.empty()) { // 转移回数据栈
            stack1.push(stack2.top());
            stack2.pop();
        }
        return res;
    }

    int peek() {
        while (!stack1.empty()) {
            stack2.push(stack1.top());
            stack1.pop();
        }
        int res = stack2.top();
        while (!stack2.empty()) {
            stack1.push(stack2.top());
            stack2.pop();
        }
        return res;
    }

    bool empty() { return stack1.empty(); }

  private:
    stack<int> stack1; // 数据栈
    stack<int> stack2; // 中转栈
};
```

但这样每次`pop`或`peek`操作都会发生大量的数据转移，可以用一个技巧来解决这个问题。同样是使用两个栈，一个作为输入栈，一个作为输出栈。`push`操作只要向输入栈`push`即可。`pop`操作时，若输出栈为空，则将所有数据都从输入栈转移到输出栈，再`pop`数据，若输出栈不为空，则可以直接`pop`输出栈。

```cpp
class MyQueue {
  public:
    MyQueue() {}

    void push(int x) { stack_in.push(x); }

    int pop() {
        int res;
        if (stack_out.empty()) { // 若输出栈空则搬移
            while (!stack_in.empty()) {
                stack_out.push(stack_in.top());
                stack_in.pop();
            }
        }
        // 否则直接pop
        res = stack_out.top();
        stack_out.pop();

        return res;
    }

    int peek() {
        int temp = this->pop(); // 借助pop
        stack_out.push(temp);   // 再将pop的元素push回输出栈
        return temp;
    }

    bool empty() { return stack_in.empty() && stack_out.empty(); }

  private:
    stack<int> stack_in;  // 输入栈
    stack<int> stack_out; // 输出栈
};
```

## [225. 用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/)（简单）

由于队列的操作方式限制，所以本题只能采取上题中的第一种思路，使用两个队列，一个作为数据队列，一个作为中转队列。

```cpp
class MyStack {
  public:
    MyStack() {}

    void push(int x) { queue1.push(x); }

    int pop() {
        int size = queue1.size() - 1;
        while (size--) { // 中转，但留下最后一个元素
            queue2.push(queue1.front());
            queue1.pop();
        }
        int res = queue1.front();
        queue1.pop();
        while (!queue2.empty()) { // 再转移回去
            queue1.push(queue2.front());
            queue2.pop();
        }

        return res;
    }

    int top() { return queue1.back(); }

    bool empty() { return queue1.empty(); }

  private:
    queue<int> queue1; // 数据队列
    queue<int> queue2; // 中转队列
};
```

## [20. 有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)（简单）

本题有一个小技巧，当碰到左括号时，入栈对应的右括号。碰到右括号就判断栈顶元素是否与当前括号相同，相同则出栈，不同则表明不匹配。

```cpp
bool isValid(string s) {
    if (s.size() % 2 != 0)
        return false;
    stack<char> st;
    for (char c : s) {
        // 碰到左括号，则push对应类型的右括号
        if (c == '(')
            st.push(')');
        else if (c == '[')
            st.push(']');
        else if (c == '{')
            st.push('}');
        // 若栈空了或栈顶元素与当前括号不相同，则括号不匹配
        else if (st.empty() || st.top() != c)
            return false;
        // 若栈顶元素与当前括号相同，则出栈
        else
            st.pop();
    }

    return st.empty();
}
```

## [1047. 删除字符串中的所有相邻重复项](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)（简单）

本题核心的思路是利用栈来记录前一个字符，下一个字符与当前栈顶元素对比，若相同则代表是相邻的重复项。

```java
string removeDuplicates(string s) {
    stack<char> st;
    for (char c : s) {
        // 栈空或栈顶元素与当前字符不相同则入栈
        if (st.empty() || st.top() != c)
            st.push(c);
        else
            st.pop();
    }

    // 栈中剩余的元素即为逆序的结果字符串
    string res("");
    while (!st.empty()) {
        res += st.top();
        st.pop();
    }
    reverse(res.begin(), res.end());

    return res;
}
```

## [150. 逆波兰表达式求值](https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/)（中等）

本题只要理解逆波兰表达式的规则就很容易做出来。若碰到数字则入栈，碰到运算符则取出栈顶的两个数字进行对应运算，再将运算结果入栈即可。

```cpp
int evalRPN(vector<string> &tokens) {
    stack<int> st;
    int left, right;
    for (string s : tokens) {
        if (s == "+" || s == "-" || s == "*" || s == "/") {
            right = st.top();
            st.pop();
            left = st.top();
            st.pop();

            if (s == "+")
                st.push(left + right);
            if (s == "-")
                st.push(left - right);
            if (s == "*")
                st.push(left * right);
            if (s == "/")
                st.push(left / right);
        } else {
            int num;
            istringstream iss(s);
            iss >> num;
            st.push(num);
        }
    }

    return st.top();
}
```

## [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)（困难）

本题暴力解法的思路很简单，但遇到`k`较大的情况会超时。力扣给出了三个提升：

- 可以使用一个双向队列；
- 队列的`size`不必和窗口的大小相同；
- 移除冗余的元素，队列只需要存储需要被考虑的元素。

结合这几条提示可以想到一种数据结构——单调队列。单调队列的`pop`和`push`操作规则如下：

- `pop`：若窗口移除的元素等于单调队列的出口元素，则将队列出口的元素弹出，否则不进行操作；
- `push`：若`push`的元素大于单调队列的入口元素，则将队列入口的元素弹出，直到`push`的元素小于等于队列入口的元素。

按照上述规则操作，每次窗口移动时，`queue.front`就是当前窗口的最大值。先借助`deque`实现单调队列。

```cpp
class MonotonicQueue {
  public:
    void pop(int value) {
        // 窗口移除元素等于队列出口元素
        if (!que.empty() && value == que.front()) {
            que.pop_front(); // 弹出出口元素
        }
    }

    void push(int value) {
        // push元素大于队列入口元素
        while (!que.empty() && value > que.back()) {
            que.pop_back(); // 弹出入口元素
        }
        // 最后向入口push元素
        que.push_back(value);
    }

    int front() { return que.front(); }

  private:
    deque<int> que;
};
```

最终利用单调队列解决本题。

```cpp
vector<int> maxSlidingWindow(vector<int> &nums, int k) {
    MonotonicQueue que;
    vector<int> res;
    // 将前k个元素放入队列
    for (int i = 0; i < k; i++) {
        que.push(nums[i]);
    }
    // 记录当前窗口最大值
    res.push_back(que.front());
    for (int i = k; i < nums.size(); i++) {
        que.pop(nums[i - k]);       // 窗口移除最前面的元素
        que.push(nums[i]);          // 窗口加入最后面的元素
        res.push_back(que.front()); // 记录当前窗口最大值
    }

    return res;
}
```

## [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)（中等）

本题要求统计前K个高频的元素，首先想到的是利用`map`来存储每个元素出现过的次数。在此基础上还需要实现按照出现次数排序的功能，可以使用优先级队列来实现，它的本质是一个堆。这里可以使用大小为K的小顶堆，因为统计的是最高频的K个元素，小顶堆每次会将最小频率的元素弹出，最后堆中剩余的元素即为前K个高频元素。

由于在优先级队列中存放的是`map`，且我们只想利用频率来排序，所以需要自定义一个比较器。

```cpp
vector<int> topKFrequent(vector<int> &nums, int k) {
    unordered_map<int, int> record;
    // 统计元素频率
    for (int num : nums) {
        record[num]++;
    }

    // 定义比较器
    auto cmp = [](const pair<int, int> &lhs, const pair<int, int> &rhs) {
        return lhs.second > rhs.second;
    };
    // 利用自定义比较器定义优先级队列
    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> small_top_heap(cmp);
    for (pair<int, int> elem : record) {
        small_top_heap.push(elem);
        // 保持小顶堆中只有k个元素
        if (small_top_heap.size() > k) {
            small_top_heap.pop();
        }
    }

    vector<int> res;
    for (int i = 0; i < k; i++) {
        res.push_back(small_top_heap.top().first);
        small_top_heap.pop();
    }

    return res;
}
```

