---
title: 算法练习——链表
tags:
  - 算法
  - 链表
  - 力扣
categories: 算法
cover: https://user-images.githubusercontent.com/56388518/193993816-dd7b5ecc-22f3-4837-9bd9-2fbeececc00a.png
abbrlink: 29899
date: 2022-03-18 16:41:16
---

# 链表

## [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)（简单）

力扣中的链表，头节点默认指向链表的第一个元素，故在解决链表问题时，可以手动增加一个虚结点作为头结点，这样可以不用单独处理原来的头节点。

```java
public ListNode removeElements(ListNode head, int val) {
    if (head == null) {
        return head;
    }

    ListNode myHead = new ListNode();
    myHead.next = head;
    ListNode pointer = myHead;
    while (pointer.next != null) {
        if (pointer.next.val == val) {
            pointer.next = pointer.next.next;
        } else {
            pointer = pointer.next;
        }
    }
    return myHead.next;
}
```

## [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)（简单）

遍历一次链表，将每个结点依次用头插法插入一个新链表中即可。

```java
public ListNode reverseList(ListNode head) {
    if (head == null) return head;
    ListNode reversedHead = new ListNode();
    ListNode pointer = head;
    do {
        ListNode node = new ListNode(pointer.val);
        node.next = reversedHead.next;
        reversedHead.next = node;
        pointer = pointer.next;
    } while (pointer != null);

    return reversedHead.next;
}
```

 本题还可以用双指针的方法解决，从头依次将指针的方向反转。

```java
public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode cur = head;
    ListNode temp = null;
    while (cur != null) {
        temp = cur.next;// 保存下一个节点
        cur.next = prev;
        prev = cur;
        cur = temp;
    }
    return prev;
}
```

还可以利用递归的方式解决，原理同双指针法一样，只不过用递归的形式表达。

```java
public ListNode reverseList(ListNode head) {
    return reverse(null, head);
}

private ListNode reverse(ListNode prev, ListNode cur) {
    if (cur == null) {
        return prev;
    }
    ListNode temp = null;
    temp = cur.next;// 先保存下一个节点
    cur.next = prev;// 反转
    // 更新prev、cur位置
    // prev = cur;
    // cur = temp;
    return reverse(cur, temp);
}
```

## [面试题 02.07. 链表相交](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)（简单）

经典问题，当两个链表长度不统一，且末尾有公共部分时，考虑将两链表的末尾对其，然后分别用指针进行遍历。

```java
public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
    int lenA = 0, lenB = 0;
    ListNode pointerA = headA, pointerB = headB;
    while (pointerA != null) {// 统计链表A的长度
        lenA++;
        pointerA = pointerA.next;
    }
    while (pointerB != null) {// 统计链表B的长度
        lenB++;
        pointerB = pointerB.next;
    }
    pointerA = headA;
    pointerB = headB;
    if (lenA < lenB) {// 使pointerA成为长链表的头
        int tempLen = lenA;
        lenA = lenB;
        lenB = tempLen;

        ListNode tempNode = pointerA;
        pointerA = pointerB;
        pointerB = tempNode;
    }
    int gap = lenA - lenB;// 计算链表长度差
    for (int i = 0; i < gap; i++) {// 先将长链表指针向后移动链表长度差，逻辑上相当于将两个链表的末尾对齐
        pointerA = pointerA.next;
    }
    while (pointerA != null) {// 两个链表同时向后移动
        if (pointerA == pointerB)// 若遇到相同结点即为交点
            return pointerA;
        pointerA = pointerA.next;
        pointerB = pointerB.next;
    }

    return null;
}
```

## [707. 设计链表](https://leetcode-cn.com/problems/design-linked-list/)（中等）

一道题考察了5个链表的基础操作，对于这种数据结构类的题要多加练习，有时候觉得在纸上画图模拟很简单，但想要用代码实现的时候会发现有很多细节问题。

以下为各方法要实现的功能：

- `get(index)`：获取链表中第 index 个节点的值。如果索引无效，则返回-1。
- `addAtHead(val)`：在链表的第一个元素之前添加一个值为`val`的节点。插入后，新节点将成为链表的第一个节点。
- `addAtTail(val)`：将值为`val`的节点追加到链表的最后一个元素。
- `addAtIndex(index,val)`：在链表中的第`index`个节点之前添加值为`val` 的节点。如果`index`等于链表的长度，则该节点将附加到链表的末尾。如果`index`大于链表长度，则不会插入节点。如果`index`小于0，则在头部插入节点。
- `deleteAtIndex(index)`：如果索引`index`有效，则删除链表中的第`index`个节点。

```java
class ListNode {
    int val;
    ListNode next;
    
    ListNode() {}
    
    ListNode(int val) {
        this.val = val;
    }
}


class MyLinkedList {

    ListNode head;
    int size;

    public MyLinkedList() {
        head = new ListNode();
        size = 0;
    }
    
    public int get(int index) {
        if (index < 0 || index >= size) return -1;
        ListNode pointer = head;
        for (int i = 0; i < index + 1; i++) {
            pointer = pointer.next;
        }
        return pointer.val;
    }
    
    public void addAtHead(int val) {
        ListNode node = new ListNode(val);
        node.next = head.next;
        head.next = node;
        size++;
    }
    
    public void addAtTail(int val) {
        ListNode pointer = head;
        while (pointer.next != null)
            pointer = pointer.next;
        ListNode node = new ListNode(val);
        pointer.next = node;
        size++;
    }
    
    public void addAtIndex(int index, int val) {
        if (index < 0) this.addAtHead(val);
        else if (index == size) this.addAtTail(val);
        else if (index > size) return;
        else {
            ListNode pointer = head;
            for (int i = 0; i < index; i++) {
                pointer = pointer.next;
            }
            ListNode node = new ListNode(val);
            node.next = pointer.next;
            pointer.next = node;
            size++;
        }
    }
    
    public void deleteAtIndex(int index) {
        if (index < 0 || index >= size) return;
        ListNode pointer = head;
        for (int i = 0; i < index; i++) {
            pointer = pointer.next;
        }
        pointer.next = pointer.next.next;
        size--;
    }
}
```

## [24. 两两交换链表中的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)（中等）

本题个人解法用了四个指针：

- `cur`和`fol`指向即将调换的两个结点
- `pre`指向`cur`的前驱，以便在两个结点交换后不会使的整个链表断裂
- `temp`用来存储`fol`的后继，也就是下一个`cur`的位置

总体思路：先将`cur`和`pre`调换，然后用`pre`将交换后的两结点重新拉入链表，再更新各指针

```java
public ListNode swapPairs(ListNode head) {
    if (head == null || head.next == null) return head;
    ListNode pointer = new ListNode();
    pointer.next = head;
    ListNode pre = pointer;
    ListNode cur = head;
    ListNode fol = cur.next;
    ListNode temp = fol.next;
    fol.next = cur;// 第一次交换
    cur.next = temp;// 第一次交换
    pre.next = fol;// 将交换后的结点重新拉回链表
    while (cur.next != null) {
        // 更新各指针
        cur = temp;
        pre = fol.next;
        fol = cur.next;
        if (fol == null) break;// 若fol为null则说明未交换的元素仅剩1个，无须再循环
        temp = fol.next;
		// 继续交换
        fol.next = cur;
        cur.next = temp;
        pre.next = fol;
    }

    return pointer.next;
}
```

可简化为三个指针的方法

```java
public ListNode swapPairs(ListNode head) {

    ListNode dummyNode = new ListNode(0);
    dummyNode.next = head;
    ListNode prev = dummyNode;

    while (prev.next != null && prev.next.next != null) {
        ListNode temp = head.next.next; // 缓存 next
        prev.next = head.next;          // 将 prev 的 next 改为 head 的 next
        head.next.next = head;          // 将 head.next(prev.next) 的next，指向 head
        head.next = temp;               // 将head 的 next 接上缓存的temp
        prev = head;                    // 步进1位
        head = head.next;               // 步进1位
    }
    return dummyNode.next;
}
```

## [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)（中等）

本题使用快慢指针法即可很简单的解决，但值得注意以下几个边界条件：

- 当链表只有一个元素，即`head.next == null`时，待删除元素必定是这个元素。
- 当快指针先走完`n`步后为`null`则表明，待删除元素必定是链表第一个元素，直接返回`head.next`即可。

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    if (head == null) return null;
    if (head.next == null) return null;
    ListNode fast = head;
    ListNode slow = head;
    for (int i = 0; i < n; i++) {
        fast = fast.next;
    }
    if (fast == null) return head.next;
    while (fast.next != null) {
        fast = fast.next;
        slow = slow.next;
    }
    slow.next = slow.next.next;

    return head;
}
```

还可以增加一个虚头结点，这样就可以不用单独处理上述方法中的边界条件

```java
public ListNode removeNthFromEnd(ListNode head, int n) {
    ListNode dummyHead = new ListNode();
    dummyHead.next = head;
    ListNode fast = dummyHead;
    ListNode slow = dummyHead;
    for (int i = 0; i < n; i++) {
        fast = fast.next;
    }
    while (fast.next != null) {
        fast = fast.next;
        slow = slow.next;
    }
    slow.next = slow.next.next;

    return dummyHead.next;
}
```

## [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)（中等）

本题可以利用`hashset`解决，从头开始遍历链表，若`hashset`中没有当前结点则将该结点加入`hashset`中，若已经包含该结点则说明该结点即为环的入口。

```java
public ListNode detectCycle(ListNode head) {
    HashSet<ListNode> listNodes = new HashSet<>();
    ListNode target = head;
    while (target != null) {
        if (listNodes.contains(target)) {
            break;
        } else {
            listNodes.add(target);
        }
        target = target.next;
    }

    return target;
}
```

本题可以用效率更高的快慢指针法

详解见：[142.环形链表II：快慢指针法](https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0142.环形链表II.md)

```java
public ListNode detectCycle(ListNode head) {
    ListNode slow = head;
    ListNode fast = head;
    while (fast != null && fast.next != null) {
        slow = slow.next;
        fast = fast.next.next;
        if (slow == fast) {// 有环
            ListNode index1 = fast;
            ListNode index2 = head;
            // 两个指针，从头结点和相遇结点，各走一步，直到相遇，相遇点即为环入口
            while (index1 != index2) {
                index1 = index1.next;
                index2 = index2.next;
            }
            return index1;
        }
    }
    return null;
}
```
