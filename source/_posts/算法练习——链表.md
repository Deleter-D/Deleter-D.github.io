---
title: 算法练习——链表
tags:
  - 算法
  - 链表
  - 力扣
categories: [算法,力扣]
toc: true
cover: https://user-images.githubusercontent.com/56388518/193993816-dd7b5ecc-22f3-4837-9bd9-2fbeececc00a.png
abbrlink: 29899
date: 2022-03-18 16:41:16
---

力扣，链表相关练习。

<!--more-->

## [203. 移除链表元素](https://leetcode-cn.com/problems/remove-linked-list-elements/)（简单）

力扣中的链表，头结点默认指向链表的第一个元素，故在解决链表问题时，可以手动增加一个虚结点作为头结点，这样可以不用单独处理原来的头结点。

```cpp
ListNode *removeElements(ListNode *head, int val) {
    ListNode *dummy_head = new ListNode(0);
    dummy_head->next = head;

    ListNode *ptr = dummy_head;
    while (ptr->next != nullptr) {
        if (ptr->next->val == val) {
            ListNode *temp = ptr->next;
            ptr->next = ptr->next->next;
            delete temp;
        } else {
            ptr = ptr->next;
        }
    }

    head = dummy_head->next;
    delete dummy_head;

    return head;
}
```

## [707. 设计链表](https://leetcode-cn.com/problems/design-linked-list/)（中等）

一道题考察了5个链表的基础操作，对于这种数据结构类的题要多加练习，有时候觉得在纸上画图模拟很简单，但想要用代码实现的时候会发现有很多细节问题。

以下为各方法要实现的功能：

- `get(index)`：获取链表中第 index 个结点的值。如果索引无效，则返回-1。
- `addAtHead(val)`：在链表的第一个元素之前添加一个值为`val`的结点。插入后，新结点将成为链表的第一个结点。
- `addAtTail(val)`：将值为`val`的结点追加到链表的最后一个元素。
- `addAtIndex(index,val)`：在链表中的第`index`个结点之前添加值为`val` 的结点。如果`index`等于链表的长度，则该结点将附加到链表的末尾。如果`index`大于链表长度，则不会插入结点。如果`index`小于0，则在头部插入结点。
- `deleteAtIndex(index)`：如果索引`index`有效，则删除链表中的第`index`个结点。

```cpp
class MyLinkedList {
  public:
    // 定义链表结点
    struct LinkedNode {
        int val;
        LinkedNode *next;
        LinkedNode(int val) : val(val), next(nullptr) {}
    };

    // 初始化链表
    MyLinkedList() {
        _dummy_head = new LinkedNode(0); // 虚头结点
        _size = 0;                       // 记录链表长度
    }

    int get(int index) {
        // 若index不合法则返回-1
        if (index > (_size - 1) || index < 0) {
            return -1;
        }
        // index从0开始，所以第0个结点是真正的头结点，不是虚头结点
        LinkedNode *ptr = _dummy_head->next;
        // for (int i = 0; i < index; i++) {
        //     ptr = ptr->next;
        // }
        while (index--) {
            ptr = ptr->next;
        }

        return ptr->val;
    }

    void addAtHead(int val) {
        LinkedNode *new_node = new LinkedNode(val);
        new_node->next = _dummy_head->next;
        _dummy_head->next = new_node;
        _size++;
    }

    void addAtTail(int val) {
        LinkedNode *new_node = new LinkedNode(val);
        LinkedNode *ptr = _dummy_head;
        while (ptr->next != nullptr) {
            ptr = ptr->next;
        }
        ptr->next = new_node;
        _size++;
    }

    void addAtIndex(int index, int val) {
        if (index > _size)
            return;
        if (index < 0)
            index = 0;

        LinkedNode *new_node = new LinkedNode(val);
        LinkedNode *ptr = _dummy_head;
        // for (int i = 0; i < index; i++) {
        //     ptr = ptr->next;
        // }
        while (index--) {
            ptr = ptr->next;
        }

        new_node->next = ptr->next;
        ptr->next = new_node;
        _size++;
    }

    void deleteAtIndex(int index) {
        if (index >= _size || index < 0)
            return;

        // 这里与get中不同，因为本质上是寻找目标结点的前一个结点
        LinkedNode *ptr = _dummy_head;
        // for (int i = 0; i < index; i++) {
        //     ptr = ptr->next;
        // }
        while (index--) {
            ptr = ptr->next;
        }

        LinkedNode *temp = ptr->next;
        ptr->next = ptr->next->next;
        delete temp;
        // 释放temp后需要赋值为nullptr，否则temp就变成了野指针，比较危险
        temp = nullptr;
        _size--;
    }

    void printLinkedList() {
        LinkedNode *ptr = _dummy_head;
        while (ptr->next != nullptr) {
            cout << ptr->next->val << " ";
            ptr = ptr->next;
        }
        cout << endl;
    }

  private:
    // 此处一定要使用有符号数，因为存在虚头结点，判断链表尺寸时可能出现-1的情况
    int _size;
    LinkedNode *_dummy_head;
};
```

## [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)（简单）

 本题可以用双指针的方法解决，从头依次将指针的方向反转。

```java
ListNode *reverseList(ListNode *head) {
    ListNode *cur = head;     // 记录当前结点
    ListNode *prev = nullptr; // 记录原链表的前一个结点

    ListNode *temp;
    while (cur != nullptr) {
        temp = cur->next; // 记录原链表中当前结点的下一个结点
        cur->next = prev; // 将当前结点的next指针反转，指向前一个结点
        prev = cur; // prev指针向原链表方向前进一步
        cur = temp; // cur指针也向原链表方向前进一步
    }
    return prev; // 当cur指向了nullptr，prev指向的就是原链表的最后一个结点
}
```

还可以利用递归的方式解决，原理同双指针法一样，只不过用递归的形式表达。

```java
ListNode *reverse(ListNode *prev, ListNode *cur) {
    if (cur == nullptr) // 递归终止条件为cur指向了nullptr
        return prev;

    ListNode *temp = cur->next;
    cur->next = prev;
    // 这里的递归等价于prev = cur; cur = temp;这两步
    return reverse(cur, temp);
}

ListNode *reverseList2(ListNode *head) {
    return reverse(nullptr, head);
}
```

## [24. 两两交换链表中的结点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)（中等）

本题直接对该过程进行模拟即可。

```cpp
ListNode *swapPairs(ListNode *head) {
    ListNode *dummy_head = new ListNode(0, head);

    ListNode *ptr = dummy_head;
    while (ptr->next != nullptr && ptr->next->next != nullptr) {
        ListNode *temp = ptr->next;              // 待交换对的左结点
        ListNode *temp1 = ptr->next->next->next; // 下一个待交换对的左结点

        ptr->next = ptr->next->next; // 上一对的右结点指向当前待交换对的右结点
        ptr->next->next = temp; // 当前待交换对的右结点指向左结点
        // 当前待交换对的左结点（即交换后的右结点）指向下一对的左结点
        ptr->next->next->next = temp1;

        ptr = ptr->next->next; // 向后移动两个结点
    }
    return dummy_head->next;
}
```

## [19. 删除链表的倒数第 N 个结点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)（中等）

本题使用快慢指针法即可很简单的解决。

```cpp
ListNode *removeNthFromEnd(ListNode *head, int n) {
    ListNode *dummy_head = new ListNode(0, head);

    ListNode *slow = dummy_head;
    ListNode *fast = dummy_head;
    for (int i = 0; i < n; i++) {
        fast = fast->next; // 快指针先走n步
    }
    // 快慢指针一起走，直到快指针指向最后一个结点
    while (fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next;
    }
    ListNode *temp = slow->next;
    slow->next = slow->next->next;
    delete temp;

    return dummy_head->next;
}
```

## [面试题 02.07. 链表相交](https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci/)（简单）

经典问题，当两个链表长度不统一，且末尾有公共部分时，考虑将两链表的末尾对其，然后分别用指针进行遍历。

```java
ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    ListNode *dummy_headA = new ListNode(0,headA);
    ListNode *dummy_headB = new ListNode(0,headB);
    
    int size_A = 0,size_B =0;
    ListNode *ptrA = dummy_headA;
    ListNode *ptrB = dummy_headB;
    while(ptrA->next != nullptr){ // 统计链表A的长度
        ptrA = ptrA->next;
        size_A++;
    }
    while(ptrB->next!=nullptr){ // 统计链表B的长度
        ptrB = ptrB->next;
        size_B++;
    }

    ptrA = dummy_headA;
    ptrB = dummy_headB;
    int diff = abs(size_A -size_B);
    // 令较长的链表先走长度差，使得ptrA和ptrB对于两个链表的末尾对齐
    if(size_A > size_B){
        for(int i=0;i<diff;i++){
            ptrA = ptrA ->next;
        }
    }else {
        for(int i=0;i<diff;i++){
            ptrB = ptrB->next;
        }   
    }

    // 然后共同前进，直到指向的结点相同
    while(ptrA != ptrB){
        ptrA = ptrA->next;
        ptrB = ptrB->next;
    }
    
    // 若到末尾都不相同，此时ptrA指向nullptr，符合要求
    return ptrA;
}
```

## [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)（中等）

本题可以使用快慢指针法，快指针每次走两步，慢指针每次走一步。这里涉及两个问题：

- 快慢指针一定相遇而不是永远错开吗？
- 快慢指针相遇的位置一定是环内吗？

第一个问题，慢指针一次走一步，快指针一次走两步，对于慢指针来说，快指针在环内是一步一步靠近慢指针的，所以早晚会相遇。

第二个问题，因为快指针一定先进入环中，而后慢指针才到。所以一旦快慢指针相遇，一定是在环内。

找到环之后，就是要找到环的入口。假设从头结点到环形入口结点的结点数为$x$。 环形入口结点到快指针与慢指针相遇结点的结点数为$y$。 从相遇结点再到环形入口结点的结点数为$z$。

当快慢指针相遇时，慢指针走过了$x+y$个结点，快指针走过了$x+y+n(y+z)$，其中$n$为快慢指针相遇时快指针在环内走的圈数。由于快指针一次走两步，慢指针一次走一步，所以快指针走过的结点数是慢指针的两倍，即$(x+y)\times2=x+y+n(y+z)$。环的入口距离头结点的距离是$x$，将式子化简就得到了$x$的值$x=n(y+z)-y$。

由于我们要找到关于环的信息，所以将公式进一步变换为$x=(n-1)(y+z)+z$，这样就将环独立了出来。这个公式的含义就比较明确了，一个指针从头结点出发，另一个指针从快慢指针相遇的结点出发，当这两个指针相遇时，就是环的入口。

```cpp
ListNode *detectCycle(ListNode *head) {
    ListNode *slow = head;
    ListNode *fast = head;
    while (fast != nullptr && fast->next != nullptr) { // 保证fast走两步的合法性
        slow = slow->next;
        fast = fast->next->next;
        if (slow == fast) {        // 若相遇则必定有环
            ListNode *ptr1 = head; // 一个指针从头结点出发
            ListNode *ptr2 = fast; // 另一个从快慢指针相遇的结点出发
            while (ptr1 != ptr2) {
                ptr1 = ptr1->next;
                ptr2 = ptr2->next;
            }
            return ptr2; // 返回环入口
        }
    }
    return nullptr;
}
```



