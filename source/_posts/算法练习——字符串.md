---
title: 算法练习——字符串
tags:
  - 算法
  - 字符串
  - 力扣
categories: 算法
cover: https://user-images.githubusercontent.com/56388518/193993968-032d7c1f-3f45-4a7f-b03e-8ff7e6d4c239.png
abbrlink: 12452
date: 2022-03-18 16:43:35
---

# 字符串

## [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)（简单）

简简单单的数组原地逆置，不多解释。

```java
public void reverseString(char[] s) {
    char temp;
    for (int i = 0; i < s.length / 2; i++) {
        temp = s[i];
        s[i] = s[s.length - i - 1];
        s[s.length - i - 1] = temp;
    }
}
```

当然还可以用异或运算实现逆置

```java
public void reverseString(char[] s) {
    int start = 0;
    int end = s.length - 1;
    while (start < end) {
        s[start] ^= s[end];  //构造 a ^ b 的结果，并放在 a 中
        s[end] ^= s[start];  //将 a ^ b 这一结果再 ^ b ，存入b中，此时 b = a, a = a ^ b
        s[start] ^= s[end];  //a ^ b 的结果再 ^ a ，存入 a 中，此时 b = a, a = b 完成交换
        start++;
        end--;
    }
}
```

## [541. 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)（简单）

将字符串转化为数组处理，遍历一次数组，用`i`做遍历指针，用`j`做计数器，每当`j == 2*k`时则认为此时`i`之前有2k个元素，则将前k个元素逆置；遍历结束后判断j与k的关系，若`j < k`则逆置剩余所有元素，若`j >= k`则逆置最后一组的前k个元素。

```java
public String reverseStr(String s, int k) {
    char[] chars = s.toCharArray();
    int i = 0, j = 1;
    while (i < chars.length) {
        i++;
        if (i == chars.length) break;
        j++;
        if (j == 2 * k) {
            reverseString(chars, i - 2 * k + 1, i - k);
            j = 0;
        }
    }
    i--;
    if (j < k) {
        reverseString(chars, i - j + 1, i);
    } else {
        reverseString(chars, i - j + 1, i - j + k);
    }
    StringBuffer buffer = new StringBuffer();
    for (char item : chars) {
        buffer.append(item);
    }

    return buffer.toString();
}


public static void reverseString(char[] s, int start, int end) {
    char temp;
    int len = end - start + 1;
    for (int i = 0; i < len / 2; i++) {
        temp = s[start + i];
        s[start+i] = s[end - i];
        s[end - i] = temp;
    }
}
```

## [剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)（简单）

```java
public String replaceSpace(String s) {
    StringBuffer buffer = new StringBuffer();
    for (Character item : s.toCharArray()) {
        if (item == ' ') {
            buffer.append("%20");
        } else {
            buffer.append(item);
        }
    }
    return buffer.toString();
}
```

## [剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)（简单）

本题先将给定的字符串推入一个`StringBuilder`中，再将前n个字符从头到尾推入`StringBuilder`的末尾，最后返回区间`[n,builder.length()]`的内容即可。

```java
public String reverseLeftWords(String s, int n) {
    StringBuilder builder = new StringBuilder();
    for (char item : s.toCharArray()) {
        builder.append(item);
    }
    for (int i = 0; i < n; i++) {
        builder.append(builder.charAt(i));
    }

    return builder.subSequence(n, builder.length()).toString();
}
```

当然也可以利用三次逆置解决，即先将前n个字符和剩余字符分别逆置，再将整个字符串逆置就得到了结果。

```java
public String reverseLeftWords(String s, int n) {
    int len=s.length();
    StringBuilder builder =new StringBuilder(s);
    reverseString(builder,0,n-1);
    reverseString(builder,n,len-1);
    return builder.reverse().toString();
}
public void reverseString(StringBuilder builder, int start, int end) {
    while (start < end) {
        char temp = builder.charAt(start);
        builder.setCharAt(start, builder.charAt(end));
        builder.setCharAt(end, temp);
        start++;
        end--;
    }
}
```

## [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)（简单）

抖机灵解法：

```java
public int strStr(String haystack, String needle) {
    return haystack.indexOf(needle);
}
```

KMP算法：但next数组是暴力法求得的

```java
public int strStr(String haystack, String needle) {
    if (needle.length() == 0) return 0;
    else if (haystack.length() == 0) return -1;
    int[] next = getNext(needle.toCharArray());
    char[] hayArr = haystack.toCharArray();
    char[] neeArr = needle.toCharArray();
    int i = 0, j = 0;
    while (i < hayArr.length && j < neeArr.length) {
        if (hayArr[i] == neeArr[j]) {
            i++;
            j++;
        } else {
            j = next[j];
            if (j == -1) {
                i++;
                j++;
            }
        }
    }
    if (j == neeArr.length) {
        return i - neeArr.length;
    } else {
        return -1;
    }
}

public int[] getNext(char[] chars) {
    int i, j, len;
    int[] next = new int[chars.length];
    next[0] = -1;
    for (j = 1; j < chars.length; j++) {
        for (len = j - 1; len >= 1; len--) {
            for (i = 0; i < len; i++) {
                if (chars[i] != chars[j - len + i]) break;
            }
            if (i == len) {
                next[j] = len;
                break;
            }
        }
        if (len < 1) {
            next[j] = 0;
        }
    }

    return next;
}
```

以下给出KMP求next数组的优化

该优化思路是利用了之前求得的next值，根据模式串前后缀的匹配以及next数组的值求得新的next数组的值。

```java
public int strStr(String haystack, String needle) {
    if (needle.length() == 0) return 0;
    int[] next = new int[needle.length()];
    getNext(next, needle);

    int j = 0;// 指向模式串
    for (int i = 0; i < haystack.length(); i++) {// 遍历主串
        while (j > 0 && needle.charAt(j) != haystack.charAt(i))// 冲突
            j = next[j - 1];// 根据next回溯
        if (needle.charAt(j) == haystack.charAt(i))// 未冲突
            j++;// 继续向后检测
        if (j == needle.length())// 若模式串被遍历完成，说明全部匹配
            return i - needle.length() + 1;// 返回本次匹配的开头
    }
    return -1;// 否则不存在匹配，返回-1
}

public void getNext(int[] next, String s) {
    int j = 0;// j指向前缀的末尾
    next[0] = 0;// 初始化next[0]
    for (int i = 1; i < s.length(); i++) {// i指向后缀的末尾
        // 若i与j所指的字符不同，则需要利用j所指的前一位字符的next值寻找最大相同前后缀字符数
        // 并要注意回溯是一个不断循环的过程，一次回溯不满足条件就需要继续回溯
        while (j > 0 && s.charAt(j) != s.charAt(i))
            j = next[j - 1];
        // 若i与j所指的字符相同，则j++，即前后缀相同的字符比上次比较多一个
        if (s.charAt(j) == s.charAt(i))
            j++;
        next[i] = j;
    }
}
```

## [459. 重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/)（简单）

`next`数组中，若`next[len - 1] != 0`则表明字符串有最长相同前后缀。

如果`len % (len - (next[len - 1] + 1)) == 0 `，则说明 (数组长度-最长相等前后缀的长度) 正好可以被数组的长度整除，说明有该字符串有重复的子字符串。

```java
public boolean repeatedSubstringPattern(String s) {
    if (s.length() == 0) return false;

    int[] next = new int[s.length()];
    getNext(next, s);
    int len = s.length();

    // len - (next[len - 1])表示最长相同前后缀的长度
    // 若len能够整除该长度，则说明整个字符串是以最长相等前后缀为周期循环的
    return next[len - 1] != 0 && len % (len - (next[len - 1])) == 0;
}

// 计算next数组，与KMP算法中的计算方式一致
public void getNext(int[] next, String s) {
    next[0] = 0;
    int j = 0;
    for (int i = 1; i < s.length(); i++) {
        while (j > 0 && s.charAt(i) != s.charAt(j)) {
            j = next[j - 1];
        }
        if (s.charAt(i) == s.charAt(j)) {
            j++;
        }
        next[i] = j;
    }
}
```

## [151. 颠倒字符串中的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)（中等）

先遍历字符串，若当前字符不是空格则将该字符推入`StringBuilder`中，若当前字符是空格则将`StringBuilder`中现有的字符作为一个单词存入一个字符串数组中，遍历结束后再遍历字符串数组，将每个不为空的元素放入空的`StringBuilder`中，每推入一个元素就推入一个空格，最后再删除末尾的空格即可。

```java
public String reverseWords(String s) {
    List<String> split = new ArrayList<>();
    StringBuilder builder = new StringBuilder();
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) != ' ') {
            builder.append(s.charAt(i));
        } else {
            split.add(builder.toString());
            builder.delete(0, builder.length());
        }
    }
    split.add(builder.toString());
    builder.delete(0, builder.length());
    for (int i = split.size() - 1; i >= 0; i--) {
        if (!split.get(i).equals("")) {
            builder.append(split.get(i));
            builder.append(" ");
        }
    }
    builder.deleteCharAt(builder.length() - 1);

    return builder.toString();
}
```

BUT：这样解决会让本题变成一道水题！

可以采用如下方法，先将整个字符串中的冗余空格去除，冗余空格指的是字符串开头和末尾的所有空格，以及单词之间多于一个的空格；然后再将整个字符串逆置，再分别将每个单词逆置，即可得到最后的结果。

```java
public String reverseWords(String s) {
    StringBuilder builder = removeSpace(s);
    reverseString(builder, 0, builder.length() - 1);
    reverseEachWords(builder);
    return builder.toString();
}

public StringBuilder removeSpace(String s) {
    int start = 0, end = s.length() - 1;
    while (s.charAt(start) == ' ') start++;// 去除开头的多余空格
    while (s.charAt(end) == ' ') end--;// 去除末尾的多余空格
    StringBuilder builder = new StringBuilder();
    while (start <= end) {
        char c = s.charAt(start);
        if (c != ' ' || builder.charAt(builder.length() - 1) != ' ') {
            builder.append(c);
        }
        start++;
    }

    return builder;
}

public void reverseString(StringBuilder builder, int start, int end) {// 逆置字符串
    while (start < end) {
        char temp = builder.charAt(start);
        builder.setCharAt(start, builder.charAt(end));
        builder.setCharAt(end, temp);
        start++;
        end--;
    }
}

public void reverseEachWords(StringBuilder builder) {// 逆置每个单词
    int start = 0, end = 1;
    int n = builder.length();
    while (start < n) {
        while (end < n && builder.charAt(end) != ' ') {// 将end往后移动找到一个完整单词
            end++;
        }
        reverseString(builder, start, end - 1);
        start = end + 1;
        end = start + 1;
    }
}
```

上述解法可以对思维加以锻炼，但依然有更好的方法，以下给出空间复杂度为$O(n)$的方法。

利用一个新的数组进行填充，从末尾遍历原数组，先跳过末尾的空格，然后每次从原数组的末尾取一个单词放入新数组中，再加一个空格，直到所有单词都放入新数组中，最后返回新数组中除最后一个空格外的部分。

```java
public String reverseWords(String s) {
    char[] chars = s.toCharArray();
    char[] newArray = new char[chars.length + 1];// 每次取的都是单词后加一个空格，最后一个单词后面也会有空格，故长度+1
    int i = chars.length - 1;// 用i从后往前遍历原始数组
    int j = 0;// 用j遍历新数组
    while (i >= 0) {
        while (i >= 0 && chars[i] == ' ') {// 跳过末尾空格
            i--;
        }
        int right = i;// 记录下i的位置，此时i指向从后往前第一个不为空格的字符，即该单词的首字母
        while (i >= 0 && chars[i] != ' ') {// 再将i向前移动到最末尾一个单词前的空格处
            i--;
        }
        for (int k = i + 1; k <= right; k++) {// 取出该单词并放入新数组中
            newArray[j] = chars[k];
            j++;
            if (k == right) {
                newArray[j] = ' ';
                j++;
            }
        }
    }
    if (j == 0) {
        return "";
    } else {
        return new String(newArray, 0, j - 1);// 最后返回[0,j-1]，即将最后一个空格去掉不返回
    }
}
```

本题还可以再优化，可以优化到空间复杂度为$O(1)$，即利用双反转+移位的操作。

详细思路见注释

```java
public String reverseWords(String s) {
    char[] chars = s.toCharArray();
    reverse(chars, 0, s.length() - 1);// 整体反转
    int k = 0;
    for (int i = 0; i < chars.length; i++) {
        if (chars[i] == ' ') {// 跳过开头冗余空格
            continue;
        }
        int current = i;// 记录下第一个非空格字符的位置
        while (i < chars.length && chars[i] != ' ') {// 继续移动i找到一个完整单词
            i++;
        }
        for (int j = current; j < i; j++) {
            if (j == current) {
                reverse(chars, current, i - 1);// 反转该单词得到正确的字母顺序
            }
            chars[k] = chars[j];// 将该单词移动到开头位置
            k++;
            if (j == i - 1) {// 遍历结束
                if (k < chars.length) {// 防止越界
                    chars[k] = ' ';
                    k++;
                }
            }
        }
    }
    if (k == 0) {
        return "";
    } else {
        // 第三个参数是为了防止出现正好凑满不需要省略空格的情况，如"hello world" => "world hello"
        return new String(chars, 0, (k == chars.length) && (chars[k - 1] != ' ') ? k : k - 1);
    }
}

public void reverse(char[] chars, int start, int end) {
    int i = start, j = end;
    while (i < j) {
        chars[i] ^= chars[j];
        chars[j] ^= chars[i];
        chars[i] ^= chars[j];
        i++;
        j--;
    }
}
```

