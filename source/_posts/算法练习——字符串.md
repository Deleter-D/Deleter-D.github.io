---
title: 算法练习——字符串
tags:
  - 算法
  - 字符串
  - 力扣
categories: [算法,力扣]
toc: true
cover: https://user-images.githubusercontent.com/56388518/193993968-032d7c1f-3f45-4a7f-b03e-8ff7e6d4c239.png
abbrlink: 12452
date: 2022-03-18 16:43:35
---

力扣，字符串相关练习。

<!--more-->

## [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)（简单）

简简单单的数组原地逆置，不多解释。

```java
void reverseString(vector<char> &s) {
    int left = 0, right = s.size() - 1;
    while (left < right) {
        char temp = s[left];
        s[left] = s[right];
        s[right] = temp;
        left++;
        right--;
    }
}
```

当然还可以用异或运算实现逆置

```java
void reverseString2(vector<char> &s) {
    int left = 0, right = s.size() - 1;
    while (left < right) {
        // 构造 a ^ b 的结果，并放在 a 中
        s[left] ^= s[right];
        // 将 a ^ b 这一结果再 ^ b ，存入b中，此时 b = a, a = a ^ b
        s[right] ^= s[left];
        // a ^ b 的结果再 ^ a ，存入 a 中，此时 b = a, a = b 完成交换
        s[left] ^= s[right];
        left++;
        right--;
    }
}
```

## [541. 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)（简单）

本题是以`2 * k`为一个单位进行反转的，每够`2k`个字符就将前`k`个字符反转。所以在遍历字符的时候就能够以`2k`为步长，只需要每次判断剩余字符的个数即可。由于`2k`个字符的情况与小于`2k`但大于`k`个字符的情况相同，均为反转前`k`个字符，所以可以将这两种情况共同处理。小于`k`个字符的情况单独处理。

```cpp
void reverse(string &s, int start, int end) {
    for (int i = start, j = end; i < j; i++, j--) {
        char temp = s[i];
        s[i] = s[j];
        s[j] = temp;
    }
}

string reverseStr(string s, int k) {
    // for循环一次前进2k个字符
    for (int i = 0; i < s.size(); i += (2 * k)) {
        // 若剩余字符小于2k但大于k个，则反转前k个
        if (i + k <= s.size()) {
            reverse(s, i, i + k - 1);
            continue;
        }
        // 剩余字符少于k个，则将剩余字符全部反转
        reverse(s, i, s.size() - 1);
    }
    return s;
}
```

## [卡码54. 替换数字](https://kamacoder.com/problempage.php?pid=1064)

本题使用额外的辅助空间会非常简单，只要遍历字符串，碰到字母就原封不动添加到新字符串中，碰到数字就向新字符串中添加字符串`number`。

```cpp
string replaceNumber(string s) {
    string res = "";
    for (int i = 0; i < s.size(); i++) {
        if (s[i] >= 'a' && s[i] <= 'z') {
            res += s[i];
        } else {
            res += "number";
        }
    }

    return res;
}
```

但进一步思考，若不借助额外的空间呢。可以先将原先的字符串扩充到替换数字后的大小，由于要将数字替换为长度为6的`number`字符串，所以每有一个数字，结果字符串长度就会增加5。

然后使用双指针法，指针`left`指向原字符串的最后一个字符，指针`right`指向扩充后的字符串的最后一个位置。然后同时向前遍历，若`left`指向的是字母，则原封不动拷贝。若`left`指向数字，则`right`指针向左移动6次，分别将`number`填充。

这里采用从后向前的方式，可以避免每次将后续字符向后拷贝，降低了时间复杂度。

```cpp
string replaceNumber(string s) {
    int count = 0;
    // 统计数字的个数
    for (int i = 0; i < s.size(); i++) {
        if (s[i] >= '0' && s[i] <= '9')
            count++;
    }
    // 扩充之前将原字符串的长度记录下来
    int left = s.size() - 1;
    // 扩充原字符串
    s.resize(s.size() + 5 * count);

    int right = s.size() - 1;
    while (left >= 0 && right >= 0) {
        if (s[left] >= '0' && s[left] <= '9') {
            s[right] = 'r';
            s[right - 1] = 'e';
            s[right - 2] = 'b';
            s[right - 3] = 'm';
            s[right - 4] = 'u';
            s[right - 5] = 'n';
            right -= 6;
        } else {
            s[right] = s[left];
            right--;
        }
        left--;
    }

    return s;
}
```

## [151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)（中等）











## [剑指 Offer 05. 替换空格](https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof/)（简单）

```java
public String replaceSpace(String s) {
    StringBuffer buffer = new StringBuffer();
    for (Character item : s.toCharArray()) {
        if (item == ' ') {
            buffer.append("%20");
        } else {
            buffer.append(item);
        }
    }
    return buffer.toString();
}
```

## [剑指 Offer 58 - II. 左旋转字符串](https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/)（简单）

本题先将给定的字符串推入一个`StringBuilder`中，再将前n个字符从头到尾推入`StringBuilder`的末尾，最后返回区间`[n,builder.length()]`的内容即可。

```java
public String reverseLeftWords(String s, int n) {
    StringBuilder builder = new StringBuilder();
    for (char item : s.toCharArray()) {
        builder.append(item);
    }
    for (int i = 0; i < n; i++) {
        builder.append(builder.charAt(i));
    }

    return builder.subSequence(n, builder.length()).toString();
}
```

当然也可以利用三次逆置解决，即先将前n个字符和剩余字符分别逆置，再将整个字符串逆置就得到了结果。

```java
public String reverseLeftWords(String s, int n) {
    int len=s.length();
    StringBuilder builder =new StringBuilder(s);
    reverseString(builder,0,n-1);
    reverseString(builder,n,len-1);
    return builder.reverse().toString();
}
public void reverseString(StringBuilder builder, int start, int end) {
    while (start < end) {
        char temp = builder.charAt(start);
        builder.setCharAt(start, builder.charAt(end));
        builder.setCharAt(end, temp);
        start++;
        end--;
    }
}
```

## [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)（简单）

抖机灵解法：

```java
public int strStr(String haystack, String needle) {
    return haystack.indexOf(needle);
}
```

KMP算法：但next数组是暴力法求得的

```java
public int strStr(String haystack, String needle) {
    if (needle.length() == 0) return 0;
    else if (haystack.length() == 0) return -1;
    int[] next = getNext(needle.toCharArray());
    char[] hayArr = haystack.toCharArray();
    char[] neeArr = needle.toCharArray();
    int i = 0, j = 0;
    while (i < hayArr.length && j < neeArr.length) {
        if (hayArr[i] == neeArr[j]) {
            i++;
            j++;
        } else {
            j = next[j];
            if (j == -1) {
                i++;
                j++;
            }
        }
    }
    if (j == neeArr.length) {
        return i - neeArr.length;
    } else {
        return -1;
    }
}

public int[] getNext(char[] chars) {
    int i, j, len;
    int[] next = new int[chars.length];
    next[0] = -1;
    for (j = 1; j < chars.length; j++) {
        for (len = j - 1; len >= 1; len--) {
            for (i = 0; i < len; i++) {
                if (chars[i] != chars[j - len + i]) break;
            }
            if (i == len) {
                next[j] = len;
                break;
            }
        }
        if (len < 1) {
            next[j] = 0;
        }
    }

    return next;
}
```

以下给出KMP求next数组的优化

该优化思路是利用了之前求得的next值，根据模式串前后缀的匹配以及next数组的值求得新的next数组的值。

```java
public int strStr(String haystack, String needle) {
    if (needle.length() == 0) return 0;
    int[] next = new int[needle.length()];
    getNext(next, needle);

    int j = 0;// 指向模式串
    for (int i = 0; i < haystack.length(); i++) {// 遍历主串
        while (j > 0 && needle.charAt(j) != haystack.charAt(i))// 冲突
            j = next[j - 1];// 根据next回溯
        if (needle.charAt(j) == haystack.charAt(i))// 未冲突
            j++;// 继续向后检测
        if (j == needle.length())// 若模式串被遍历完成，说明全部匹配
            return i - needle.length() + 1;// 返回本次匹配的开头
    }
    return -1;// 否则不存在匹配，返回-1
}

public void getNext(int[] next, String s) {
    int j = 0;// j指向前缀的末尾
    next[0] = 0;// 初始化next[0]
    for (int i = 1; i < s.length(); i++) {// i指向后缀的末尾
        // 若i与j所指的字符不同，则需要利用j所指的前一位字符的next值寻找最大相同前后缀字符数
        // 并要注意回溯是一个不断循环的过程，一次回溯不满足条件就需要继续回溯
        while (j > 0 && s.charAt(j) != s.charAt(i))
            j = next[j - 1];
        // 若i与j所指的字符相同，则j++，即前后缀相同的字符比上次比较多一个
        if (s.charAt(j) == s.charAt(i))
            j++;
        next[i] = j;
    }
}
```

## [459. 重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/)（简单）

`next`数组中，若`next[len - 1] != 0`则表明字符串有最长相同前后缀。

如果`len % (len - (next[len - 1] + 1)) == 0 `，则说明 (数组长度-最长相等前后缀的长度) 正好可以被数组的长度整除，说明有该字符串有重复的子字符串。

```java
public boolean repeatedSubstringPattern(String s) {
    if (s.length() == 0) return false;

    int[] next = new int[s.length()];
    getNext(next, s);
    int len = s.length();

    // len - (next[len - 1])表示最长相同前后缀的长度
    // 若len能够整除该长度，则说明整个字符串是以最长相等前后缀为周期循环的
    return next[len - 1] != 0 && len % (len - (next[len - 1])) == 0;
}

// 计算next数组，与KMP算法中的计算方式一致
public void getNext(int[] next, String s) {
    next[0] = 0;
    int j = 0;
    for (int i = 1; i < s.length(); i++) {
        while (j > 0 && s.charAt(i) != s.charAt(j)) {
            j = next[j - 1];
        }
        if (s.charAt(i) == s.charAt(j)) {
            j++;
        }
        next[i] = j;
    }
}
```

## [151. 颠倒字符串中的单词](https://leetcode-cn.com/problems/reverse-words-in-a-string/)（中等）

先遍历字符串，若当前字符不是空格则将该字符推入`StringBuilder`中，若当前字符是空格则将`StringBuilder`中现有的字符作为一个单词存入一个字符串数组中，遍历结束后再遍历字符串数组，将每个不为空的元素放入空的`StringBuilder`中，每推入一个元素就推入一个空格，最后再删除末尾的空格即可。

```java
public String reverseWords(String s) {
    List<String> split = new ArrayList<>();
    StringBuilder builder = new StringBuilder();
    for (int i = 0; i < s.length(); i++) {
        if (s.charAt(i) != ' ') {
            builder.append(s.charAt(i));
        } else {
            split.add(builder.toString());
            builder.delete(0, builder.length());
        }
    }
    split.add(builder.toString());
    builder.delete(0, builder.length());
    for (int i = split.size() - 1; i >= 0; i--) {
        if (!split.get(i).equals("")) {
            builder.append(split.get(i));
            builder.append(" ");
        }
    }
    builder.deleteCharAt(builder.length() - 1);

    return builder.toString();
}
```

BUT：这样解决会让本题变成一道水题！

可以采用如下方法，先将整个字符串中的冗余空格去除，冗余空格指的是字符串开头和末尾的所有空格，以及单词之间多于一个的空格；然后再将整个字符串逆置，再分别将每个单词逆置，即可得到最后的结果。

```java
public String reverseWords(String s) {
    StringBuilder builder = removeSpace(s);
    reverseString(builder, 0, builder.length() - 1);
    reverseEachWords(builder);
    return builder.toString();
}

public StringBuilder removeSpace(String s) {
    int start = 0, end = s.length() - 1;
    while (s.charAt(start) == ' ') start++;// 去除开头的多余空格
    while (s.charAt(end) == ' ') end--;// 去除末尾的多余空格
    StringBuilder builder = new StringBuilder();
    while (start <= end) {
        char c = s.charAt(start);
        if (c != ' ' || builder.charAt(builder.length() - 1) != ' ') {
            builder.append(c);
        }
        start++;
    }

    return builder;
}

public void reverseString(StringBuilder builder, int start, int end) {// 逆置字符串
    while (start < end) {
        char temp = builder.charAt(start);
        builder.setCharAt(start, builder.charAt(end));
        builder.setCharAt(end, temp);
        start++;
        end--;
    }
}

public void reverseEachWords(StringBuilder builder) {// 逆置每个单词
    int start = 0, end = 1;
    int n = builder.length();
    while (start < n) {
        while (end < n && builder.charAt(end) != ' ') {// 将end往后移动找到一个完整单词
            end++;
        }
        reverseString(builder, start, end - 1);
        start = end + 1;
        end = start + 1;
    }
}
```

上述解法可以对思维加以锻炼，但依然有更好的方法，以下给出空间复杂度为$O(n)$的方法。

利用一个新的数组进行填充，从末尾遍历原数组，先跳过末尾的空格，然后每次从原数组的末尾取一个单词放入新数组中，再加一个空格，直到所有单词都放入新数组中，最后返回新数组中除最后一个空格外的部分。

```java
public String reverseWords(String s) {
    char[] chars = s.toCharArray();
    char[] newArray = new char[chars.length + 1];// 每次取的都是单词后加一个空格，最后一个单词后面也会有空格，故长度+1
    int i = chars.length - 1;// 用i从后往前遍历原始数组
    int j = 0;// 用j遍历新数组
    while (i >= 0) {
        while (i >= 0 && chars[i] == ' ') {// 跳过末尾空格
            i--;
        }
        int right = i;// 记录下i的位置，此时i指向从后往前第一个不为空格的字符，即该单词的首字母
        while (i >= 0 && chars[i] != ' ') {// 再将i向前移动到最末尾一个单词前的空格处
            i--;
        }
        for (int k = i + 1; k <= right; k++) {// 取出该单词并放入新数组中
            newArray[j] = chars[k];
            j++;
            if (k == right) {
                newArray[j] = ' ';
                j++;
            }
        }
    }
    if (j == 0) {
        return "";
    } else {
        return new String(newArray, 0, j - 1);// 最后返回[0,j-1]，即将最后一个空格去掉不返回
    }
}
```

本题还可以再优化，可以优化到空间复杂度为$O(1)$，即利用双反转+移位的操作。

详细思路见注释

```java
public String reverseWords(String s) {
    char[] chars = s.toCharArray();
    reverse(chars, 0, s.length() - 1);// 整体反转
    int k = 0;
    for (int i = 0; i < chars.length; i++) {
        if (chars[i] == ' ') {// 跳过开头冗余空格
            continue;
        }
        int current = i;// 记录下第一个非空格字符的位置
        while (i < chars.length && chars[i] != ' ') {// 继续移动i找到一个完整单词
            i++;
        }
        for (int j = current; j < i; j++) {
            if (j == current) {
                reverse(chars, current, i - 1);// 反转该单词得到正确的字母顺序
            }
            chars[k] = chars[j];// 将该单词移动到开头位置
            k++;
            if (j == i - 1) {// 遍历结束
                if (k < chars.length) {// 防止越界
                    chars[k] = ' ';
                    k++;
                }
            }
        }
    }
    if (k == 0) {
        return "";
    } else {
        // 第三个参数是为了防止出现正好凑满不需要省略空格的情况，如"hello world" => "world hello"
        return new String(chars, 0, (k == chars.length) && (chars[k - 1] != ' ') ? k : k - 1);
    }
}

public void reverse(char[] chars, int start, int end) {
    int i = start, j = end;
    while (i < j) {
        chars[i] ^= chars[j];
        chars[j] ^= chars[i];
        chars[i] ^= chars[j];
        i++;
        j--;
    }
}
```

