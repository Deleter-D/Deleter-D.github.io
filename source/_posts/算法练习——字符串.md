---
title: 算法练习——字符串
tags:
  - 算法
  - 字符串
  - 力扣
categories: [算法,力扣]
toc: true
cover: https://user-images.githubusercontent.com/56388518/193993968-032d7c1f-3f45-4a7f-b03e-8ff7e6d4c239.png
abbrlink: 12452
date: 2022-03-18 16:43:35
---

力扣，字符串相关练习。

<!--more-->

## [344. 反转字符串](https://leetcode-cn.com/problems/reverse-string/)（简单）

简简单单的数组原地逆置，不多解释。

```java
void reverseString(vector<char> &s) {
    int left = 0, right = s.size() - 1;
    while (left < right) {
        char temp = s[left];
        s[left] = s[right];
        s[right] = temp;
        left++;
        right--;
    }
}
```

当然还可以用异或运算实现逆置

```java
void reverseString2(vector<char> &s) {
    int left = 0, right = s.size() - 1;
    while (left < right) {
        // 构造 a ^ b 的结果，并放在 a 中
        s[left] ^= s[right];
        // 将 a ^ b 这一结果再 ^ b ，存入b中，此时 b = a, a = a ^ b
        s[right] ^= s[left];
        // a ^ b 的结果再 ^ a ，存入 a 中，此时 b = a, a = b 完成交换
        s[left] ^= s[right];
        left++;
        right--;
    }
}
```

## [541. 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)（简单）

本题是以`2 * k`为一个单位进行反转的，每够`2k`个字符就将前`k`个字符反转。所以在遍历字符的时候就能够以`2k`为步长，只需要每次判断剩余字符的个数即可。由于`2k`个字符的情况与小于`2k`但大于`k`个字符的情况相同，均为反转前`k`个字符，所以可以将这两种情况共同处理。小于`k`个字符的情况单独处理。

```cpp
void reverse(string &s, int start, int end) {
    for (int i = start, j = end; i < j; i++, j--) {
        char temp = s[i];
        s[i] = s[j];
        s[j] = temp;
    }
}

string reverseStr(string s, int k) {
    // for循环一次前进2k个字符
    for (int i = 0; i < s.size(); i += (2 * k)) {
        // 若剩余字符小于2k但大于k个，则反转前k个
        if (i + k <= s.size()) {
            reverse(s, i, i + k - 1);
            continue;
        }
        // 剩余字符少于k个，则将剩余字符全部反转
        reverse(s, i, s.size() - 1);
    }
    return s;
}
```

## [卡码54. 替换数字](https://kamacoder.com/problempage.php?pid=1064)

本题使用额外的辅助空间会非常简单，只要遍历字符串，碰到字母就原封不动添加到新字符串中，碰到数字就向新字符串中添加字符串`number`。

```cpp
string replaceNumber(string s) {
    string res = "";
    for (int i = 0; i < s.size(); i++) {
        if (s[i] >= 'a' && s[i] <= 'z') {
            res += s[i];
        } else {
            res += "number";
        }
    }

    return res;
}
```

但进一步思考，若不借助额外的空间呢。可以先将原先的字符串扩充到替换数字后的大小，由于要将数字替换为长度为6的`number`字符串，所以每有一个数字，结果字符串长度就会增加5。

然后使用双指针法，指针`left`指向原字符串的最后一个字符，指针`right`指向扩充后的字符串的最后一个位置。然后同时向前遍历，若`left`指向的是字母，则原封不动拷贝。若`left`指向数字，则`right`指针向左移动6次，分别将`number`填充。

这里采用从后向前的方式，可以避免每次将后续字符向后拷贝，降低了时间复杂度。

```cpp
string replaceNumber(string s) {
    int count = 0;
    // 统计数字的个数
    for (int i = 0; i < s.size(); i++) {
        if (s[i] >= '0' && s[i] <= '9')
            count++;
    }
    // 扩充之前将原字符串的长度记录下来
    int left = s.size() - 1;
    // 扩充原字符串
    s.resize(s.size() + 5 * count);

    int right = s.size() - 1;
    while (left >= 0 && right >= 0) {
        if (s[left] >= '0' && s[left] <= '9') {
            s[right] = 'r';
            s[right - 1] = 'e';
            s[right - 2] = 'b';
            s[right - 3] = 'm';
            s[right - 4] = 'u';
            s[right - 5] = 'n';
            right -= 6;
        } else {
            s[right] = s[left];
            right--;
        }
        left--;
    }

    return s;
}
```

## [151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)（中等）

本题建议使用`O(1)`的空间复杂度解，所以就只能原地想办法。该题要求将单词顺序反转，但单词本身不反转，可以利用两次反转来解决。第一次将整个字符串反转，此时每个单词也是反转的状态，第二次再将每个单词单独反转，就正回来了。但输入字符串还有多余的空格，要优先去除掉这些空格。

```cpp
void removeExtraSpace(string &s) {
    int slow = 0, fast = 0;
    // 去除字符串开头的空格
    while (s.size() > 0 && fast < s.size() && s[fast] == ' ') {
        fast++;
    }
    for (; fast < s.size(); fast++) {
        // 去掉字符串中间的冗余空格，只保留一个空格
        if (fast - 1 > 0 && s[fast - 1] == s[fast] && s[fast] == ' ') {
            continue;
        } else {
            s[slow] = s[fast];
            slow++;
        }
    }
    if (slow - 1 > 0 && s[slow - 1] == ' ') {
        // 去除字符串末尾的空格
        s.resize(slow - 1);
    } else {
        s.resize(slow);
    }
}
```

去除空格可以用双指针法，先借助快指针去除开头的所有空格。然后开始处理中间的冗余空格，若遇到空格，则快指针向前走，直到遇到下一个非空格的字符，然后将快指针指向的字符赋值给慢指针指向的字符，此时快慢指针同时向前一步。最后处理末尾的空格，只需要简单的`resize`即可。

此外还需要一个反转字符串的函数，之前已经提到过了。

```cpp
void reverse(string &s, int start, int end) {
    for (int i = start, j = end; i < j; i++, j--) {
        swap(s[i], s[j]);
    }
}
```

最终的处理如下。

```cpp
string reverseWords(string s) {
    // 去除冗余空格
    removeExtraSpace(s);
    // 先整个反转
    reverse(s, 0, s.size() - 1);

    int start = 0;
    for (int i = 0; i <= s.size(); i++) {
        // 再逐单词反转
        if (i == s.size() || s[i] == ' ') {
            reverse(s, start, i - 1);
            start = i + 1;
        }
    }

    return s;
}
```

## [卡码55. 右旋字符串](https://kamacoder.com/problempage.php?pid=1065)

本题要求将字符串右旋指定位数，常规的解法可以先将待右旋的部分记录下来，再将这部分拼接到原字符串前面，最后将拼接好的字符串`resize`到原大小即可。

```cpp
void rightRotate(int k, string &s) {
    int size = s.size();
    // 记录待右旋部分
    string temp(s.cbegin() + s.size() - k, s.cend());
    s = temp + s;
    s.resize(size);
}
```

但本题可以原地解决，参考上一题的思路。可以先将字符串整体反转，然后将待右旋的部分和剩余部分再分别反转，就是所求结果。

```cpp
void rightRotate(int k, string &s) {
    // 整体反转
    reverse(s.begin(), s.end());
    // 两部分分别反转
    reverse(s.begin(), s.begin() + k);
    reverse(s.begin() + k, s.end());
}
```

## [28. 找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)（简单）

本题用到一个经典算法——KMP算法，主要用于匹配字符串。当字符串不匹配时，可以知道一部分已经匹配的内容，而不需要重新从头匹配。

前缀表是KMP算法的核心，它记录了模式串下标`i`（包括`i`）之前的子串的最长公共前后缀长度。

以模式串`aabaaf`为例，子串`a`的最长公共前后缀长度为0，子串`aa`的为1，子串`aab`为0，子串`aaba`为1，子串`aabaa`为2，最后`aabaaf`为0。

当字符串遇到不匹配的字符时，模式串的指针向前移动长度为前一个字符的最长公共前后缀长度。

这里还涉及一个概念就是`next`数组，`next`可以是前缀表本身，也可以是前缀表整体减1后的数组。这里减不减一无关KMP算法的原理，只是实现上不同。

首先要建立`next`数组。

```cpp
vector<int> getNext(string s) {
    // i指向前缀末尾，j指向后缀末尾
    vector<int> next(s.size());
    int j = -1;
    next[0] = j; // 初始化为-1
    // j初始化为-1,所以i从1开始，与j+1比较
    for (int i = 1; i < s.size(); i++) {
        // 前后缀不同的情况
        while (j >= 0 && s[i] != s[j + 1]) {
            j = next[j]; // 向前回退
        }
        if (s[i] == s[j + 1]) { // 前后缀相同
            j++;
        }
        next[i] = j; // 记录最长公共前后缀长度
    }
    return next;
}
```

然后利用`next`数组进行模式匹配。

```cpp
int strStr(string haystack, string needle) {
    if (needle.size() == 0)
        return 0;

    vector<int> next = getNext(needle);
    int j = -1; // 因为next数组记录的起始位置为-1
    // 这里i从0开始
    for (int i = 0; i < haystack.size(); i++) {
        // 字符不匹配的情况
        while (j >= 0 && haystack[i] != needle[j + 1]) {
            j = next[j]; // 寻找之前匹配的位置
        }
        // 字符匹配则i，j同时向后移动
        if (haystack[i] == needle[j + 1]) {
            j++;
        }
        // 字符串完全匹配
        if (j == (needle.size() - 1)) {
            return (i - needle.size() + 1);
        }
    }
    return -1;
}
```

> KMP算法详细的解释参考[代码随想录](https://programmercarl.com/0028.%E5%AE%9E%E7%8E%B0strStr.html)。

## [459. 重复的子字符串](https://leetcode-cn.com/problems/repeated-substring-pattern/)（简单）

当一个字符串是由重复的子串构成的，那么它一定可以分为几部分，每一部分都是一样的子串。这样的字符串如果进行前后拼接，那么必然在拼接起来的新字符串的中间部分找到一个原字符串，所以就有了如下解法。

```cpp
bool repeatedSubstringPattern(string s) {
    string t = s + s;     // 拼接
    t.erase(t.begin());   // 掐头
    t.erase(t.end() - 1); // 去尾
    // find()函数未找到时会返回string::npos
    if (t.find(s) != string::npos)
        return true;

    return false;
}
```

当然也可以用上题的KMP算法，通过`next`数组来判断是否具有重复子串。

```cpp
vector<int> getNext(string s) {
    vector<int> next(s.size());
    next[0] = -1;
    int j = -1;
    for (int i = 1; i < s.size(); i++) {
        while (j >= 0 && s[i] != s[j + 1]) {
            j = next[j];
        }
        if (s[i] == s[j + 1]) {
            j++;
        }
        next[i] = j;
    }

    return next;
}

bool repeatedSubstringPattern2(string s) {
    if (s.size() == 0) {
        return false;
    }

    vector<int> next = getNext(s);
    int size = s.size();
    // 若next[size - 1] != -1说明字符串中存在最长公共前后缀
    // 如果字符串长度-最长公共前后缀长度可以被字符串长度整除
    // 即 size % (size - (next[size - 1] + 1)) == 0
    // 说明有重复的子串
    if (next[size - 1] != -1 && size % (size - (next[size - 1] + 1)) == 0) {
        return true;
    }

    return false;
}
```

