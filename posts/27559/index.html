<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>以张量角度考虑softmax算子 - 亦初</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="亦初"><meta name="msapplication-TileImage" content="https://user-images.githubusercontent.com/56388518/193990104-d040c2b4-1b96-4636-b410-b2ccd6360665.jpg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="亦初"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="在之前的文章中已经介绍了Softmax算子开发的整体思路，但笔者只从向量的角度进行了说明，本篇文章就以处理张量的角度来进一步阐述。"><meta property="og:type" content="blog"><meta property="og:title" content="亦初"><meta property="og:url" content="https://deleter-d.github.io/"><meta property="og:site_name" content="亦初"><meta property="og:description" content="在之前的文章中已经介绍了Softmax算子开发的整体思路，但笔者只从向量的角度进行了说明，本篇文章就以处理张量的角度来进一步阐述。"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://user-images.githubusercontent.com/56388518/193990104-d040c2b4-1b96-4636-b410-b2ccd6360665.jpg"><meta property="article:published_time" content="2023-12-05T08:01:50.000Z"><meta property="article:modified_time" content="2023-12-05T08:55:08.153Z"><meta property="article:author" content="亦初"><meta property="article:tag" content="毕昇编译器"><meta property="article:tag" content="异构编程"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://user-images.githubusercontent.com/56388518/193990104-d040c2b4-1b96-4636-b410-b2ccd6360665.jpg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://deleter-d.github.io/posts/27559/"},"headline":"亦初","image":[],"datePublished":"2023-12-05T08:01:50.000Z","dateModified":"2023-12-05T08:55:08.153Z","author":{"@type":"Person","name":"亦初"},"description":"在之前的文章中已经介绍了Softmax算子开发的整体思路，但笔者只从向量的角度进行了说明，本篇文章就以处理张量的角度来进一步阐述。"}</script><link rel="canonical" href="https://deleter-d.github.io/posts/27559/"><link rel="icon" href="https://user-images.githubusercontent.com/56388518/193990104-d040c2b4-1b96-4636-b410-b2ccd6360665.jpg"><meta name="referrer" content="no-referrer-when-downgrade"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css?family=Ubuntu:400,600|Source+Code+Pro|Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Microsoft YaHei:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&amp;amp;subset=latin,latin-ext|Inconsolata|Itim|Lobster.css"><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="/js/globalUtils.js"></script><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><script src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" defer></script><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><meta name="generator" content="Hexo 5.4.2"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style><link rel="alternate" href="/atom.xml" title="亦初" type="application/atom+xml">
</head><body class="is-3-column has-navbar-fixed-top"><nav class="navbar navbar-main is-fixed-top"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="https://user-images.githubusercontent.com/56388518/193990104-d040c2b4-1b96-4636-b410-b2ccd6360665.jpg" alt="亦初" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">首页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/music">音乐</a><a class="navbar-item" href="/message">留言</a><a class="navbar-item" href="/self-talking">碎碎念</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item is-hidden-tablet catalogue" title="目录" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a><a class="navbar-item" id="night-nav" title="Night Mode" href="javascript:;"><i class="fas fa-moon" id="night-icon"></i></a></div></div></div></nav><script type="text/javascript" src="/js/theme-setting.js"></script><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><!--!--><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><i class="far fa-calendar-plus"> </i>2023-12-05  <a class="commentCountImg" href="/posts/27559/#comment-container"><span class="display-none-class">b3e74bc7499bf1536e3a590043a96757</span><i class="far fa-comment-dots"></i> <span class="commentCount" id="b3e74bc7499bf1536e3a590043a96757">99+</span>  </a><span class="level-item"><i class="far fa-clock"> </i>27 分钟  <i class="fas fa-pencil-alt"> </i>4.1 k</span><span class="level-item" id="busuanzi_container_page_pv"><span id="busuanzi_value_page_pv">0</span>次访问</span></div></div><h1 class="title is-3 is-size-4-mobile">以张量角度考虑softmax算子</h1><div class="content"><p>在之前的文章中已经介绍了Softmax算子开发的整体思路，但笔者只从向量的角度进行了说明，本篇文章就以处理张量的角度来进一步阐述。</p>
<span id="more"></span>
<h1 id="张量的内存排布">张量的内存排布</h1>
<p>要使Softmax算子处理张量，首先要了解张量在内存上的排布，我们用<code>numpy</code>的<code>ndarray</code>来说明。</p>
<p>首先利用<code>python</code>来创建一个<code>ndarray</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>data = np.random.randn(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>).astype(np.float32)<br></code></pre></td></tr></table></figure>
<p>然后我们写一个简单的<code>C++</code>函数（<code>tensor.cpp</code>），该函数接受一个对应数据类型的指针作为参数，功能就简单的打印输出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-string">"C"</span> <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printTensor</span><span class="hljs-params">(<span class="hljs-type">float</span> *tensor, <span class="hljs-type">int</span> *shape)</span></span>{<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; shape[<span class="hljs-number">0</span>]; i++) {<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; shape[<span class="hljs-number">1</span>]; j++) {<br>            std::cout &lt;&lt; tensor[i * shape[<span class="hljs-number">0</span>] + j] &lt;&lt; <span class="hljs-string">" "</span>;<br>        }<br>        std::cout &lt;&lt; <span class="hljs-string">"\n"</span>;<br>    }<br>}<br></code></pre></td></tr></table></figure>
<p>其中的<code>extern "C"</code>是必要的，否则调用时会出现<code>undefined symbol</code>问题。</p>
<p>然后将其编译成一个动态链接库，以供<code>python</code>调用，命令如下。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">g++ -shared -fPIC -o tensor.so tensor.cpp<br></code></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果代码中使用了<code>C++</code>的标准库，则编译器要使用<code>g++</code>而不是<code>gcc</code>，否则会出现标准库符号找不到的问题，<code>clang</code>同理。</p>
</blockquote>
<p>编译好后在<code>python</code>中调用该库，数据类型的转换是利用<code>ctypes</code>来实现的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">from</span> ctypes <span class="hljs-keyword">import</span> CDLL, POINTER, c_float, c_int<br><br>data = np.random.randn(<span class="hljs-number">32</span>, <span class="hljs-number">32</span>).astype(np.float32)<br>c_int_arr = c_int * <span class="hljs-built_in">len</span>(data.shape)<br><br>lib = CDLL(<span class="hljs-string">"./tensor.so"</span>) <span class="hljs-comment"># 获取动态链接库</span><br>printTensor = lib.printTensor <span class="hljs-comment"># 获取库中的函数符号</span><br>printTensor.argtypes = [ <span class="hljs-comment"># 定义函数的参数类型</span><br>    POINTER(c_float),<br>    POINTER(c_int),<br>]<br><br><span class="hljs-comment"># 函数调用</span><br>printTensor(<br>    data.ctypes.data_as(POINTER(c_float)), <span class="hljs-comment"># 将numpy的ndarray转换为C语言的float职责</span><br>    c_int_arr(data.shape[<span class="hljs-number">0</span>], data.shape[<span class="hljs-number">1</span>]), <span class="hljs-comment"># 将形状信息也传递给C++</span><br>)<br></code></pre></td></tr></table></figure>
<p>部分执行结果如下所示。</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">-<span class="hljs-number">1.48456 0</span>.<span class="hljs-number">336725 1</span>.<span class="hljs-number">69846</span> -<span class="hljs-number">0.0248114</span> <span class="hljs-number">0.39322 0</span>.<span class="hljs-number">614784 0</span>.<span class="hljs-number">326595 0</span>.<span class="hljs-number">575949</span> -<span class="hljs-number">0.708058</span> -<span class="hljs-number">1.39587</span> -<span class="hljs-number">1.83477 0</span>.<span class="hljs-number">349339</span> -<span class="hljs-number">0.610898</span> -<span class="hljs-number">0.423076</span> -<span class="hljs-number">0.136989 0</span>.<span class="hljs-number">442269 0</span>.<span class="hljs-number">446412</span> -<span class="hljs-number">0.486558</span> -<span class="hljs-number">0.292987</span> <span class="hljs-number">1.29332 0</span>.<span class="hljs-number">187811 0</span>.<span class="hljs-number">331237 0</span>.<span class="hljs-number">63905</span> -<span class="hljs-number">1.46251</span> -<span class="hljs-number">0.536956</span> <span class="hljs-number">0.495119</span> -<span class="hljs-number">0.429213</span> -<span class="hljs-number">0.988436</span> -<span class="hljs-number">0.414105</span> -<span class="hljs-number">2.26553 1</span>.<span class="hljs-number">23408</span> -<span class="hljs-number">0.544561</span> <br><span class="hljs-number">0.369648</span> -<span class="hljs-number">1.12966</span> -<span class="hljs-number">0.154628 1</span>.<span class="hljs-number">09682 0</span>.<span class="hljs-number">676383 0</span>.<span class="hljs-number">444374</span> -<span class="hljs-number">0.706796</span> -<span class="hljs-number">0.873308</span> -<span class="hljs-number">1.32488</span> -<span class="hljs-number">0.537758</span> -<span class="hljs-number">1.81611</span> -<span class="hljs-number">2.06588 0</span>.<span class="hljs-number">721618 1</span>.<span class="hljs-number">02888</span> -<span class="hljs-number">0.919128</span> -<span class="hljs-number">0.765203</span> -<span class="hljs-number">0.42332 0</span>.<span class="hljs-number">0602946 1</span>.<span class="hljs-number">16713 0</span>.<span class="hljs-number">140398</span> -<span class="hljs-number">0.534829</span> -<span class="hljs-number">0.0961945</span> <span class="hljs-number">0.0153079</span> -<span class="hljs-number">0.261519</span> <span class="hljs-number">0.0927059</span> -<span class="hljs-number">0.868659</span> <span class="hljs-number">1.27008</span> -<span class="hljs-number">0.379786</span> <span class="hljs-number">0.382002</span> -<span class="hljs-number">1.76778 0</span>.<span class="hljs-number">660476 1</span>.<span class="hljs-number">06135</span><br>...<br></code></pre></td></tr></table></figure>
<p>以上得出结论，<code>numpy</code>中的张量在内存上就是一个<strong>一维数组</strong>，可以用指针来操作，其他框架的张量同理。</p>
<h1 id="算子逻辑">算子逻辑</h1>
<p>由于张量在内存上都是一维排布的，所以最内层维度在内存上是连续的。所以对于昇腾芯片来说，<code>Softmax</code>最适合加速的就是在张量的最后一个维度上进行计算，下面的讨论都基于最后一个维度。对于一个NHWC的张量来说，我们在最后一个维度上进行<code>Softmax</code>也是实际中最常用的情况。</p>
<p>算子涉及向量自然指数、向量归约求和、向量除法等运算，其中最需要关心的就是向量归约求和，因为它涉及到对齐的问题。</p>
<h2 id="可能的数据情况">可能的数据情况</h2>
<p>主要有以下几种情况：</p>
<h3 id="情况一数据repeat对齐">情况一：数据<code>repeat</code>对齐</h3>
<p>最好解决的就是<code>repeat</code>对齐的情况，不需要做尾块处理，直接利用<code>vec_cross_add()</code>归约求和即可。</p>
<p><img src="https://github.com/Deleter-D/Images/assets/56388518/32e28548-e1d0-4781-b340-fa7631e1fba8"></p>
<h3 id="情况二数据部分repeat对齐部分block对齐">情况二：数据部分<code>repeat</code>对齐，部分<code>block</code>对齐</h3>
<p>对于部分<code>repeat</code>对齐，部分<code>block</code>对齐的情况，需要分开来处理。对于<code>repeat</code>对齐的部分同样简单处理，对于<code>block</code>对齐的部分，无法直接调用<code>vec_cross_add</code>接口进行归约求和，需要利用标量操作来累加进前面的结果中。</p>
<p><img src="https://github.com/Deleter-D/Images/assets/56388518/9beafb91-6f29-4fbf-bc9b-5f3ba6996c4c"></p>
<h3 id="情况三数据部分repeat对齐部分block对齐剩余尾块block不对齐">情况三：数据部分<code>repeat</code>对齐，部分<code>block</code>对齐，剩余尾块<code>block</code>不对齐</h3>
<p>最后一种情况是最需要注意的情况，而且实际使用中大部分是这种情况。着重关注非<code>block</code>对齐部分的数据，这部分数据要从搬移的时候就开始做单独处理。因为GM与UB之间的数据搬移最小粒度是一个<code>block</code>，无法真正做到元素级别的搬移。</p>
<p><img src="https://github.com/Deleter-D/Images/assets/56388518/3f33eedc-f0df-47f2-992c-acde552b4b62" style="zoom: 67%;"></p>
<p>对于这种情况的数据搬移，我们考虑一种简化情况，即数据长度大于一个<code>block</code>但不足两个<code>block</code>。对于这样的数据，GM与UB之间的搬移需要一个临时空间来辅助。</p>
<p><img src="https://github.com/Deleter-D/Images/assets/56388518/dd30457f-da75-4fbc-8f4c-fab2a5dc42b6" style="zoom:50%;"></p>
<p>具体方式是从末尾向前取一个整<code>block</code>进行搬移，这样不会影响到后续的数据，同时使得<code>group</code>之间的访存严格隔离开来。</p>
<p>这样处理的时候，由于会有被重复搬移的数据，所以要注意在累加的时候不要重复累加元素。</p>
<h2 id="算子实现">算子实现</h2>
<p>为了避免张量过大，在UB上申请的空间超出限制，这里使<code>group</code>循环分批处理一个向量。即从GM搬移进UB，处理完后再搬回GM，再搬入下一批数据进行处理，直到所有数据被处理完成。</p>
<p>这样处理有一个好处就是，情况二和情况三的数据只会出现在最后一次迭代中。该算子的处理大体分为三个小模块，求<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.157ex" height="1.553ex" role="img" focusable="false" viewBox="0 -675.5 953.5 686.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(499,363) scale(0.707)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></g></svg></mjx-container></span>、归约求和以及向量除法。</p>
<p>在写核心逻辑之前，我们需要为算子准备一系列的常量，方便后面使用。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 一个向量的repeat数量</span><br>std::<span class="hljs-type">size_t</span> total_repeat_count = vec_bytes / REPEAT_SIZE;<br><span class="hljs-comment">// 需要的核内迭代次数</span><br>std::<span class="hljs-type">size_t</span> iteration_times = total_repeat_count / MAX_REPEAT_PER_ITERATION + <span class="hljs-number">1</span>;<br><span class="hljs-comment">// 最后一次迭代处理的字节数</span><br>std::<span class="hljs-type">size_t</span> last_iter_bytes = vec_bytes - (iteration_times - <span class="hljs-number">1</span>) * MAX_BYTES_PER_ITERATION;<br><span class="hljs-comment">// 最后一次迭代数据中元素的个数</span><br>std::<span class="hljs-type">size_t</span> elem_count = last_iter_bytes / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>);<br><span class="hljs-comment">// 最后一次迭代数据中对齐block的个数</span><br>std::<span class="hljs-type">size_t</span> block_count = last_iter_bytes / BLOCK_SIZE;<br><span class="hljs-comment">// 最后一次迭代数据中对齐repeate的个数</span><br>std::<span class="hljs-type">size_t</span> repeat_count = last_iter_bytes / REPEAT_SIZE;<br><span class="hljs-comment">// 最后一次迭代数据中block对齐的元素个数</span><br>std::<span class="hljs-type">size_t</span> align_block_elem_count = block_count * BLOCK_SIZE / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>);<br><span class="hljs-comment">// 最后一次迭代数据中repeat对齐的元素个数</span><br>std::<span class="hljs-type">size_t</span> align_repeat_elem_count = repeat_count * REPEAT_SIZE / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>);<br><span class="hljs-comment">// 最后一次迭代数据中非对齐元素个数</span><br>std::<span class="hljs-type">size_t</span> tail_elem_count = elem_count - align_block_elem_count;<br><span class="hljs-comment">// 最后一次迭代数据中非对齐字节数</span><br>std::<span class="hljs-type">size_t</span> tail_bytes = tail_elem_count * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>);<br><span class="hljs-comment">// 最后一次迭代数据中，向前取整block的元素个数</span><br>std::<span class="hljs-type">size_t</span> tail_block_elem_count = BLOCK_SIZE / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>);<br><span class="hljs-comment">// 最后一次迭代数据中，向前取整block的起点索引</span><br>std::<span class="hljs-type">size_t</span> tail_memcpy_index = dim2 - tail_block_elem_count;<br></code></pre></td></tr></table></figure>
<p>核心逻辑如下，详细说明见注释。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (std::<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; iteration_times; i++) {<br>  index = group_id * dim2 + i * MAX_BYTES_PER_ITERATION / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>);<br>  <span class="hljs-keyword">if</span> (i == iteration_times - <span class="hljs-number">1</span>) {<br>    tail_index = group_id * dim2 + tail_memcpy_index;<br>    <span class="hljs-comment">// 加载最后一次迭代中，block对齐的数据</span><br>    input_vec.<span class="hljs-built_in">load</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_tensor + index).<span class="hljs-built_in">get</span>(), align_block_elem_count);<br>    <span class="hljs-keyword">if</span> (tail_bytes) {<br>      <span class="hljs-comment">// 加载最后一次迭代中，block非对齐的数据，向前取整block</span><br>      temp.<span class="hljs-built_in">load</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_tensor + tail_index).<span class="hljs-built_in">get</span>(), tail_block_elem_count);<br>    }<br>    bisheng::<span class="hljs-built_in">vec_exp</span>(input_vec.<span class="hljs-built_in">to_view</span>(elem_count), input_vec.<span class="hljs-built_in">to_view</span>(elem_count));<br>    bisheng::<span class="hljs-built_in">vec_exp</span>(temp, temp);<br>    input_vec.<span class="hljs-built_in">store</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_tensor + index).<span class="hljs-built_in">get</span>(), align_block_elem_count);<br>    <span class="hljs-keyword">if</span> (tail_bytes) {<br>      temp.<span class="hljs-built_in">store</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_tensor + tail_index).<span class="hljs-built_in">get</span>(), tail_block_elem_count);<br>    }<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-comment">// 整块的数据</span><br>    input_vec.<span class="hljs-built_in">load</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_tensor + index).<span class="hljs-built_in">get</span>(), MAX_BYTES_PER_ITERATION / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>));<br>    bisheng::<span class="hljs-built_in">vec_exp</span>(input_vec, input_vec);<br>    input_vec.<span class="hljs-built_in">store</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_tensor + index).<span class="hljs-built_in">get</span>(), MAX_BYTES_PER_ITERATION / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>));<br>  }<br>}<br><br><span class="hljs-comment">// 计算向量和</span><br><span class="hljs-keyword">for</span> (std::<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; iteration_times; i++) {<br>  index = group_id * dim2 + i * MAX_BYTES_PER_ITERATION / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>);<br>  <span class="hljs-keyword">if</span> (i == iteration_times - <span class="hljs-number">1</span>) {<br>    tail_index = group_id * dim2 + tail_memcpy_index;<br>    <span class="hljs-comment">// 加载最后一次迭代中，block对齐的数据</span><br>    input_vec.<span class="hljs-built_in">load</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_tensor + index).<span class="hljs-built_in">get</span>(), align_block_elem_count);<br>    <span class="hljs-keyword">if</span> (tail_bytes) {<br>      <span class="hljs-comment">// 加载最后一次迭代中，block非对齐的数据，向前取整block</span><br>      temp.<span class="hljs-built_in">load</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_tensor + tail_index).<span class="hljs-built_in">get</span>(), tail_block_elem_count);<br>    }<br>    <span class="hljs-keyword">if</span> (align_repeat_elem_count) {<br>      <span class="hljs-comment">// 将最后一次迭代中repeat对齐的数据求和</span><br>      bisheng::<span class="hljs-built_in">vec_cross_add</span>(sum_vec.<span class="hljs-built_in">to_view</span>(repeat_count, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), input_vec.<span class="hljs-built_in">to_view</span>(align_repeat_elem_count));<br>      <span class="hljs-keyword">for</span> (std::<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; repeat_count; j++) {<br>        sum += sum_vec[j];<br>      }<br>    }<br>    <span class="hljs-comment">// 计算repeat不对齐，但block部分对齐的数据</span><br>    <span class="hljs-keyword">for</span> (std::<span class="hljs-type">size_t</span> j = align_repeat_elem_count; j &lt; align_block_elem_count; j++) {<br>      sum += input_vec[j];<br>    }<br>    <span class="hljs-comment">// 计算block不对齐的数据</span><br>    <span class="hljs-keyword">for</span> (std::<span class="hljs-type">size_t</span> j = tail_block_elem_count - tail_elem_count; j &lt; tail_block_elem_count; j++) {<br>      sum += temp[j];<br>    }<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-comment">// 整块的数据</span><br>    input_vec.<span class="hljs-built_in">load</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_tensor + index).<span class="hljs-built_in">get</span>(), MAX_BYTES_PER_ITERATION / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>));<br>    bisheng::<span class="hljs-built_in">vec_cross_add</span>(sum_vec.<span class="hljs-built_in">to_view</span>(MAX_REPEAT_PER_ITERATION, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), input_vec.<span class="hljs-built_in">to_view</span>(MAX_BYTES_PER_ITERATION / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)));<br>    <span class="hljs-keyword">for</span> (std::<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; MAX_BYTES_PER_ITERATION / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>); j++) {<br>      sum += sum_vec[j];<br>    }<br>  }<br>}<br><br><span class="hljs-comment">// 利用向量和初始化分母向量</span><br>bisheng::vector&lt;<span class="hljs-type">float</span>, BLOCK_SIZE / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>)&gt; temp_res;<br><span class="hljs-function">bisheng::vector&lt;<span class="hljs-type">float</span>, MAX_BYTES_PER_ITERATION / <span class="hljs-title">sizeof</span><span class="hljs-params">(<span class="hljs-type">float</span>)</span>&gt; <span class="hljs-title">divisor</span><span class="hljs-params">(sum)</span></span>;<br><span class="hljs-function">bisheng::vector&lt;<span class="hljs-type">float</span>, BLOCK_SIZE / <span class="hljs-title">sizeof</span><span class="hljs-params">(<span class="hljs-type">float</span>)</span>&gt; <span class="hljs-title">temp_divisor</span><span class="hljs-params">(sum)</span></span>;<br><br><span class="hljs-keyword">for</span> (std::<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; iteration_times; i++) {<br>  index = group_id * dim2 + i * MAX_BYTES_PER_ITERATION / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>);<br>  <span class="hljs-keyword">if</span> (i == iteration_times - <span class="hljs-number">1</span>) {<br>    tail_index = group_id * dim2 + tail_memcpy_index;<br>    <span class="hljs-comment">// 加载最后一次迭代中，block对齐的数据</span><br>    input_vec.<span class="hljs-built_in">load</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_tensor + index).<span class="hljs-built_in">get</span>(), align_block_elem_count);<br>    <span class="hljs-keyword">if</span> (tail_bytes) {<br>      <span class="hljs-comment">// 加载最后一次迭代中，block非对齐的数据，向前取整block</span><br>      temp.<span class="hljs-built_in">load</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_tensor + tail_index).<span class="hljs-built_in">get</span>(), tail_block_elem_count);<br>    }<br>    bisheng::<span class="hljs-built_in">vec_div</span>(res_vec.<span class="hljs-built_in">to_view</span>(elem_count), input_vec.<span class="hljs-built_in">to_view</span>(elem_count), divisor.<span class="hljs-built_in">to_view</span>(elem_count));<br>    bisheng::<span class="hljs-built_in">vec_div</span>(temp_res, temp, temp_divisor);<br>    res_vec.<span class="hljs-built_in">store</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_tensor + index).<span class="hljs-built_in">get</span>(), align_block_elem_count);<br>    <span class="hljs-keyword">if</span> (tail_bytes) {<br>      temp_res.<span class="hljs-built_in">store</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_tensor + tail_index).<span class="hljs-built_in">get</span>(), tail_block_elem_count);<br>    }<br>  } <span class="hljs-keyword">else</span> {<br>    <span class="hljs-comment">// 整块的数据</span><br>    input_vec.<span class="hljs-built_in">load</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_tensor + index).<span class="hljs-built_in">get</span>(), MAX_BYTES_PER_ITERATION / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>));<br>    bisheng::<span class="hljs-built_in">vec_div</span>(res_vec, input_vec, divisor);<br>    res_vec.<span class="hljs-built_in">store</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_tensor + index).<span class="hljs-built_in">get</span>(), MAX_BYTES_PER_ITERATION / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>));<br>  }<br>}<br></code></pre></td></tr></table></figure>
<h1 id="算子优化">算子优化</h1>
<h2 id="算子逻辑优化">算子逻辑优化</h2>
<p>观察上述的核心逻辑，可以观察到几个比较明显的优化点：</p>
<ul>
<li>计算<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.157ex" height="1.553ex" role="img" focusable="false" viewBox="0 -675.5 953.5 686.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(499,363) scale(0.707)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></g></svg></mjx-container></span>和归约求和的过程可以合并，不需要先计算<span class="math inline"><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.025ex;" xmlns="http://www.w3.org/2000/svg" width="2.157ex" height="1.553ex" role="img" focusable="false" viewBox="0 -675.5 953.5 686.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msup"><g data-mml-node="mi"><path data-c="1D452" d="M39 168Q39 225 58 272T107 350T174 402T244 433T307 442H310Q355 442 388 420T421 355Q421 265 310 237Q261 224 176 223Q139 223 138 221Q138 219 132 186T125 128Q125 81 146 54T209 26T302 45T394 111Q403 121 406 121Q410 121 419 112T429 98T420 82T390 55T344 24T281 -1T205 -11Q126 -11 83 42T39 168ZM373 353Q367 405 305 405Q272 405 244 391T199 357T170 316T154 280T149 261Q149 260 169 260Q282 260 327 284T373 353Z"></path></g><g data-mml-node="mi" transform="translate(499,363) scale(0.707)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g></g></g></svg></mjx-container></span>后搬出，再搬入计算归约和；</li>
<li>最后计算除法的过程，可以用倒数乘法来代替；</li>
<li>可以开启<code>double buffering</code>。</li>
</ul>
<p>优化后的核心逻辑如下所示。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 计算e^x并归约求和</span><br><span class="hljs-keyword">for</span> (std::<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; iteration_times; i++) {<br>  index = group_id * dim2 + i * MAX_BYTES_PER_ITERATION / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>);<br>  <span class="hljs-comment">// 判断当前缓冲区</span><br>  <span class="hljs-keyword">auto</span> &amp;input_vec = i % <span class="hljs-number">2</span> ? input_vec_0 : input_vec_1;<br>  <span class="hljs-keyword">auto</span> &amp;sum_vec = i % <span class="hljs-number">2</span> ? sum_vec_0 : sum_vec_1;<br>  <span class="hljs-keyword">auto</span> &amp;sum_temp = i % <span class="hljs-number">2</span> ? sum_temp_0 : sum_temp_1;<br>  <span class="hljs-keyword">auto</span> &amp;sum = i % <span class="hljs-number">2</span> ? sum_0 : sum_1;<br><br>  <span class="hljs-keyword">if</span> (i == iteration_times - <span class="hljs-number">1</span>) {<br>    tail_index = group_id * dim2 + tail_memcpy_index;<br>    <span class="hljs-comment">// 加载最后一次迭代中，block对齐的数据</span><br>    <span class="hljs-keyword">if</span> (align_block_elem_count) {<br>      input_vec.<span class="hljs-built_in">load</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_tensor + index).<span class="hljs-built_in">get</span>(), align_block_elem_count);<br>      bisheng::<span class="hljs-built_in">vec_exp</span>(input_vec.<span class="hljs-built_in">to_view</span>(elem_count), input_vec.<span class="hljs-built_in">to_view</span>(elem_count));<br>      <span class="hljs-comment">// 将最后一次迭代中repeat对齐的数据求和</span><br>      <span class="hljs-keyword">if</span> (align_repeat_elem_count) {<br>        bisheng::<span class="hljs-built_in">vec_cross_add</span>(sum_vec.<span class="hljs-built_in">to_view</span>(repeat_count, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), input_vec.<span class="hljs-built_in">to_view</span>());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; repeat_count; j++) {<br>          sum += sum_vec[j];<br>        }<br>      }<br>      <span class="hljs-comment">// 计算repeat不对齐，但block部分对齐的数据</span><br>      <span class="hljs-keyword">for</span> (std::<span class="hljs-type">size_t</span> j = align_repeat_elem_count; j &lt; align_block_elem_count; j++) {<br>        sum += input_vec[j];<br>      }<br>      input_vec.<span class="hljs-built_in">store</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_exp_tensor + index).<span class="hljs-built_in">get</span>(), align_block_elem_count);<br>    }<br>    <span class="hljs-keyword">if</span> (tail_bytes) {<br>      <span class="hljs-comment">// 加载最后一次迭代中，block非对齐的数据，向前取整block</span><br>      temp.<span class="hljs-built_in">load</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_tensor + tail_index).<span class="hljs-built_in">get</span>(), tail_block_elem_count);<br>      bisheng::<span class="hljs-built_in">vec_exp</span>(temp, temp);<br>      <span class="hljs-comment">// 计算block不对齐的数据</span><br>      <span class="hljs-keyword">for</span> (std::<span class="hljs-type">size_t</span> j = tail_block_elem_count - tail_elem_count; j &lt; tail_block_elem_count; j++) {<br>        sum += temp[j];<br>      }<br>      temp.<span class="hljs-built_in">store</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_exp_tensor + tail_index).<span class="hljs-built_in">get</span>(), tail_block_elem_count);<br>    }<br><br>  } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 整块的数据</span><br>    input_vec.<span class="hljs-built_in">load</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_tensor + index).<span class="hljs-built_in">get</span>(), MAX_BYTES_PER_ITERATION / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>));<br>    bisheng::<span class="hljs-built_in">vec_exp</span>(input_vec, input_vec);<br>    bisheng::<span class="hljs-built_in">vec_cross_add</span>(sum_vec.<span class="hljs-built_in">to_view</span>(MAX_REPEAT_PER_ITERATION, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), input_vec.<span class="hljs-built_in">to_view</span>(MAX_BYTES_PER_ITERATION / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>)));<br>    bisheng::<span class="hljs-built_in">vec_cross_add</span>(sum_temp.<span class="hljs-built_in">to_view</span>(sum_vec_repeat_count, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>), sum_vec.<span class="hljs-built_in">to_view</span>(MAX_REPEAT_PER_ITERATION));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; sum_vec_repeat_count; j++) {<br>      sum += sum_temp[j];<br>    }<br>    input_vec.<span class="hljs-built_in">store</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_exp_tensor + index).<span class="hljs-built_in">get</span>(), MAX_BYTES_PER_ITERATION / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>));<br>  }<br>}<br><br><span class="hljs-comment">// 两个缓冲区的和相加</span><br>sum_0 += sum_1;<br><span class="hljs-keyword">auto</span> &amp;sum = sum_0;<br><br>bisheng::vector&lt;<span class="hljs-type">float</span>, BLOCK_SIZE / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>)&gt; temp_res;<br><span class="hljs-type">float</span> divisor = <span class="hljs-number">1</span> / sum;<br><br><span class="hljs-comment">// 向量除法</span><br><span class="hljs-keyword">for</span> (std::<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; iteration_times; i++) {<br>  index = group_id * dim2 + i * MAX_BYTES_PER_ITERATION / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>);<br>  <span class="hljs-comment">// 判断当前缓冲区</span><br>  <span class="hljs-keyword">auto</span> &amp;input_vec = i % <span class="hljs-number">2</span> ? input_vec_0 : input_vec_1;<br>  <span class="hljs-keyword">auto</span> &amp;res_vec = i % <span class="hljs-number">2</span> ? res_vec_0 : res_vec_1;<br>  <span class="hljs-keyword">if</span> (i == iteration_times - <span class="hljs-number">1</span>) {<br>    tail_index = group_id * dim2 + tail_memcpy_index;<br>    <span class="hljs-comment">// 加载最后一次迭代中，block对齐的数据</span><br>    <span class="hljs-keyword">if</span> (align_block_elem_count) {<br>      input_vec.<span class="hljs-built_in">load</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_exp_tensor + index).<span class="hljs-built_in">get</span>(), align_block_elem_count);<br>      bisheng::<span class="hljs-built_in">vec_mul</span>(res_vec.<span class="hljs-built_in">to_view</span>(elem_count), input_vec.<span class="hljs-built_in">to_view</span>(elem_count), divisor);<br>      res_vec.<span class="hljs-built_in">store</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_tensor + index).<span class="hljs-built_in">get</span>(), align_block_elem_count);<br>    }<br>    <span class="hljs-keyword">if</span> (tail_bytes) {<br>      <span class="hljs-comment">// 加载最后一次迭代中，block非对齐的数据，向前取整block</span><br>      temp.<span class="hljs-built_in">load</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_exp_tensor + tail_index).<span class="hljs-built_in">get</span>(), tail_block_elem_count);<br>      bisheng::<span class="hljs-built_in">vec_mul</span>(temp_res, temp, divisor);<br>      temp_res.<span class="hljs-built_in">store</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_tensor + tail_index).<span class="hljs-built_in">get</span>(), tail_block_elem_count);<br>    }<br>  } <span class="hljs-keyword">else</span> { <span class="hljs-comment">// 整块的数据</span><br>    input_vec.<span class="hljs-built_in">load</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_exp_tensor + index).<span class="hljs-built_in">get</span>(), MAX_BYTES_PER_ITERATION / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>));<br>    bisheng::<span class="hljs-built_in">vec_mul</span>(res_vec, input_vec, divisor);<br>    res_vec.<span class="hljs-built_in">store</span>(sycl::<span class="hljs-built_in">global_ptr</span>&lt;<span class="hljs-type">float</span>&gt;(d_tensor + index).<span class="hljs-built_in">get</span>(), MAX_BYTES_PER_ITERATION / <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>));<br>  }<br>}<br></code></pre></td></tr></table></figure>
<h2 id="分核方案优化">分核方案优化</h2>
<p>由于毕昇异构算子中存在一个限制，即<code>group</code>的数量最大为65535。按照上述的分核方案，最多只能处理65535个向量，显然是不合理的。所以，当向量个数大于65535时，要令每个逻辑核处理多个向量。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 每个group处理的向量个数</span><br>std::<span class="hljs-type">size_t</span> vec_count_per_group = (vec_count + MAX_KERNEL_COUNT - <span class="hljs-number">1</span>) / MAX_KERNEL_COUNT;<br><span class="hljs-comment">// 开启的group数量</span><br>std::<span class="hljs-type">size_t</span> group_count = (vec_count + vec_count_per_group - <span class="hljs-number">1</span>) / vec_count_per_group;<br></code></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">for</span> (std::<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; vec_count_per_group; i++) {<br>  iteration_begin = group_index + i * dim3;<br>  <span class="hljs-keyword">if</span> (iteration_begin &gt;= element_total_count) <span class="hljs-comment">// 注意判断边界</span><br>    <span class="hljs-keyword">break</span>;<br>  bisheng::vector&lt;<span class="hljs-type">float</span>, MAX_BYTES_PER_ITERATION / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>)&gt; input_vec_0;<br>  bisheng::vector&lt;<span class="hljs-type">float</span>, MAX_BYTES_PER_ITERATION / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>)&gt; input_vec_1;<br>  <span class="hljs-function">bisheng::vector&lt;<span class="hljs-type">float</span>, MAX_REPEAT_PER_ITERATION&gt; <span class="hljs-title">sum_vec_0</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-function">bisheng::vector&lt;<span class="hljs-type">float</span>, MAX_REPEAT_PER_ITERATION&gt; <span class="hljs-title">sum_vec_1</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-type">const</span> std::<span class="hljs-type">size_t</span> sum_vec_repeat_count = MAX_REPEAT_PER_ITERATION * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">float</span>) / REPEAT_SIZE;<br>  <span class="hljs-function">bisheng::vector&lt;<span class="hljs-type">float</span>, sum_vec_repeat_count&gt; <span class="hljs-title">sum_temp_0</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  <span class="hljs-function">bisheng::vector&lt;<span class="hljs-type">float</span>, sum_vec_repeat_count&gt; <span class="hljs-title">sum_temp_1</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;<br>  bisheng::vector&lt;<span class="hljs-type">float</span>, MAX_BYTES_PER_ITERATION / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>)&gt; res_vec_0;<br>  bisheng::vector&lt;<span class="hljs-type">float</span>, MAX_BYTES_PER_ITERATION / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>)&gt; res_vec_1;<br>  bisheng::vector&lt;<span class="hljs-type">float</span>, BLOCK_SIZE / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>)&gt; temp;<br>  __local <span class="hljs-type">float</span> sum_0 = <span class="hljs-number">0.0f</span>;<br>  __local <span class="hljs-type">float</span> sum_1 = <span class="hljs-number">0.0f</span>;<br><br>  <span class="hljs-comment">// 计算e^x并归约求和</span><br>  <span class="hljs-keyword">for</span> (std::<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; iteration_times; j++) {<br>    ...<br>  }<br><br>  <span class="hljs-comment">// 两个缓冲区的和相加</span><br>  sum_0 += sum_1;<br>  <span class="hljs-keyword">auto</span> &amp;sum = sum_0;<br><br>  bisheng::vector&lt;<span class="hljs-type">float</span>, BLOCK_SIZE / <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">float</span>)&gt; temp_res;<br>  <span class="hljs-type">float</span> divisor = <span class="hljs-number">1</span> / sum;<br><br>  <span class="hljs-comment">// 向量除法</span><br>  <span class="hljs-keyword">for</span> (std::<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; iteration_times; j++) {<br>    ...<br>  }<br>}<br></code></pre></td></tr></table></figure>
<h1 id="功能测试">功能测试</h1>
<p>功能测试采取将算子封装到<code>MindSpore</code>框架中进行测试，具体方案如下。先将算子代码编译为动态链接库。</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">clang++ -fsycl -fdevices=ascend_910 \<br>    -I <span class="hljs-variable">${ASCEND_TOOLKIT_HOME}</span>/include \<br>    -L <span class="hljs-variable">${ASCEND_TOOLKIT_HOME}</span>/lib64 -lascendcl \<br>    -shared -fPIC -o softmax.so \<br>    -mllvm -inline-threshold=9000 -mllvm -enable-explicit-vectorizer -Rpass=ascend-vec \<br>    ./softmax.cpp<br></code></pre></td></tr></table></figure>
<p>然后按照要求封装为<code>MindSpore</code>可调用的状态。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">SoftmaxBS</span>(<span class="hljs-title class_ inherited__">Cell</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>(SoftmaxBS, self).__init__()<br>        self.bisheng_softmax = ops.Custom(<br>            <span class="hljs-string">"softmax.so:softmax_npu"</span>,<br>            out_shape=<span class="hljs-keyword">lambda</span> x: x,<br>            out_dtype=<span class="hljs-keyword">lambda</span> x: x,<br>            func_type=<span class="hljs-string">"aot"</span>,<br>        )<br>        self.bisheng_softmax.add_prim_attr(<span class="hljs-string">"primitive_target"</span>, <span class="hljs-string">"Ascend"</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">construct</span>(<span class="hljs-params">self, x0</span>):<br>        output = self.bisheng_softmax(x0)<br>        <span class="hljs-keyword">return</span> output<br></code></pre></td></tr></table></figure>
<p>在结果正确性方面，采用了<code>numpy</code>中的<code>allClose()</code>函数来对比<code>MindSpore</code>算子与自定义算子的结果张量，若两者在一定精度范围内接近，则认为计算结果正确。具体判断逻辑如下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">context.set_context(mode=ms.PYNATIVE_MODE, device_target=<span class="hljs-string">"Ascend"</span>)<br>softmax_bs = SoftmaxBS()<br>softmax = Softmax(axis=-<span class="hljs-number">1</span>)<br>data = ms.Tensor(np.random.randn(dim0, dim1, dim2, dim3), ms.float16)<br>output_bs = softmax_bs(data)<br>output_ms = softmax(data)<br><span class="hljs-keyword">if</span> np.allclose(output_bs.asnumpy(), output_ms.asnumpy(), rtol=<span class="hljs-number">1e-3</span>, atol=<span class="hljs-number">1e-3</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"correct!"</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">"error!"</span>)<br></code></pre></td></tr></table></figure>
<p>经过测试，算子逻辑没有问题，精度由于使用了<code>float16</code>来计算，所以只设置到了<code>1e-3</code>。</p>
<h1 id="性能测试">性能测试</h1>
<p>性能测试采用单算子测试的方式。对于<code>MindSpore</code>中的算子，采用框架自带的<code>Profiler()</code>来分析算子性能，再通过<code>msprof.py</code>脚本工具导出算子性能数据的<code>summary</code>数据，通过读取<code>Task Duration</code>列来获取算子的执行时间。而对于自定义算子，则采用<code>msprof</code>命令行工具运行算子，同样通过<code>summary</code>数据来获取算子执行时间。</p>
<table>
<thead>
<tr class="header">
<th>ID</th>
<th>Shape</th>
<th>数据类型</th>
<th>MindSpore</th>
<th>BiSheng</th>
<th>加速比</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>1</td>
<td>8x16x1024x1024</td>
<td>half</td>
<td>2658.672</td>
<td>9720.826</td>
<td>0.273503</td>
</tr>
<tr class="even">
<td>2</td>
<td>16x16x1024x1024</td>
<td>half</td>
<td>5274.796</td>
<td>18483.56</td>
<td>0.285378</td>
</tr>
<tr class="odd">
<td>3</td>
<td>16x16x1024x2048</td>
<td>half</td>
<td>10550.81</td>
<td>21184.74</td>
<td>0.498038</td>
</tr>
<tr class="even">
<td>4</td>
<td>16x16x1024x4096</td>
<td>half</td>
<td>22255.22</td>
<td>26612.28</td>
<td>0.836276</td>
</tr>
<tr class="odd">
<td>5</td>
<td>4x4x512x8192</td>
<td>half</td>
<td>1221.49</td>
<td>1350.776</td>
<td>0.904288</td>
</tr>
<tr class="even">
<td>6</td>
<td>4x4x512x16384</td>
<td>half</td>
<td>2438.494</td>
<td>1337.628</td>
<td>1.822999</td>
</tr>
<tr class="odd">
<td>7</td>
<td>4x4x512x32768</td>
<td>half</td>
<td>4869.044</td>
<td>2412.854</td>
<td>2.01796</td>
</tr>
<tr class="even">
<td>8</td>
<td>4x4x512x65535</td>
<td>half</td>
<td>6671.878</td>
<td>6200.692</td>
<td>1.075989</td>
</tr>
<tr class="odd">
<td>9</td>
<td>4x4x512x131072</td>
<td>half</td>
<td>19467.07</td>
<td>8748.974</td>
<td>2.225069</td>
</tr>
<tr class="even">
<td>10</td>
<td>4x4x512x8193</td>
<td>half</td>
<td>4984.124</td>
<td>1564.236</td>
<td>3.186299</td>
</tr>
<tr class="odd">
<td>11</td>
<td>4x4x512x16385</td>
<td>half</td>
<td>1354.314</td>
<td>1555.814</td>
<td>0.870486</td>
</tr>
<tr class="even">
<td>12</td>
<td>4x4x512x32769</td>
<td>half</td>
<td>4288.27</td>
<td>2667.928</td>
<td>1.607341</td>
</tr>
<tr class="odd">
<td>13</td>
<td>4x4x512x65536</td>
<td>half</td>
<td>9732.024</td>
<td>4516.888</td>
<td>2.154586</td>
</tr>
<tr class="even">
<td>14</td>
<td>4x4x512x131073</td>
<td>half</td>
<td>79671.69</td>
<td>9390.606</td>
<td>8.484191</td>
</tr>
</tbody>
</table>
<p>经过一系列的性能测试，发现在小数据量的情况下，性能始终无法与TBE算子相比。推测可能的原因是，TBE算子针对某些静态形状有优化，但本算子针对的是动态形状场景，所以性能较差。但当数据量变大，充分发挥设备并行能力的情况下，性能有所好转。在其最擅长的形状上，加速比可以达到2左右，在用例14这种情况下，加速比甚至达到了8以上。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>以张量角度考虑softmax算子</p><p><a href="https://deleter-d.github.io/posts/27559/">https://deleter-d.github.io/posts/27559/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><a href="https://deleter-d.github.io"><p>亦初</p></a></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2023-12-05</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2023-12-05</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="recommend-area"><div class="recommend-post"><span class="is-size-6 has-text-grey has-mr-7"># 相关文章</span><br><span>  1.<a class="is-size-6" href="/posts/18632/" target="_blank">csv文件对于不同形状张量的存储与解析</a><br></span><span>  2.<a class="is-size-6" href="/posts/63148/" target="_blank">毕昇编译器异构算子分核方案再探</a><br></span><span>  3.<a class="is-size-6" href="/posts/1040/" target="_blank">关于vec_cross_add接口的详细测试</a><br></span><span>  4.<a class="is-size-6" href="/posts/15984/" target="_blank">基于毕昇编译器的softmax异构算子</a><br></span><span>  5.<a class="is-size-6" href="/posts/58921/" target="_blank">毕昇异构算子数据搬移注意事项</a><br></span><span>  6.<a class="is-size-6" href="/posts/29203/" target="_blank">毕昇编译器版本升级注意事项</a><br></span><span>  7.<a class="is-size-6" href="/posts/35929/" target="_blank">毕昇异构算子开发全流程</a><br></span><span>  8.<a class="is-size-6" href="/posts/11914/" target="_blank">毕昇编译器异构算子开发基本思想</a><br></span></div></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/css/share.min.css"><div class="social-share"></div><script src="https://cdnjs.loli.net/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">喜欢这篇文章？打赏一下作者吧</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>支付宝</span><span class="qrcode"><img src="https://user-images.githubusercontent.com/56388518/194691384-1d4515ba-79ae-4e83-a485-bfaa5c64033e.jpg" alt="支付宝"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>微信</span><span class="qrcode"><img src="https://user-images.githubusercontent.com/56388518/194691371-ad26d43d-b3b5-4fe5-9fc0-52a31333ca98.jpg" alt="微信"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/posts/22702/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">打造vscode般的neovim</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/posts/18632/"><span class="level-item">csv文件对于不同形状张量的存储与解析</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--><div class="card"><div class="card-content"><div class="title is-5">评论</div><div id="comment-container"></div><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/gitalk/1.6.0/gitalk.css"><script> $.getScript('/js/gitalk.min.js', function () { 
            var gitalk = new Gitalk({
            language:'zh-CN',
            id: 'b3e74bc7499bf1536e3a590043a96757',
            repo: 'Deleter-D.github.io',
            owner: 'Deleter-D',
            clientID: 'd087baa8a532e3b31fba',
            clientSecret: 'faec4c1d7046247c200bca62c9930d0799ce58a5',
            admin: ["Deleter-D"],
            createIssueManually: true,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: 'last',
            proxy: 'https://cloudflare-cors-anywhere.wyp867909454.workers.dev/?https://github.com/login/oauth/access_token',
            
            enableHotKey: true,
            isLocked: false
        })
        gitalk.render('comment-container')});</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">目录</h3><ul class="menu-list"><li><a class="is-flex is-mobile" href="#张量的内存排布"><span>张量的内存排布</span></a></li><li><a class="is-flex is-mobile" href="#算子逻辑"><span>算子逻辑</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#可能的数据情况"><span>可能的数据情况</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#情况一数据repeat对齐"><span>情况一：数据repeat对齐</span></a></li><li><a class="is-flex is-mobile" href="#情况二数据部分repeat对齐部分block对齐"><span>情况二：数据部分repeat对齐，部分block对齐</span></a></li><li><a class="is-flex is-mobile" href="#情况三数据部分repeat对齐部分block对齐剩余尾块block不对齐"><span>情况三：数据部分repeat对齐，部分block对齐，剩余尾块block不对齐</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#算子实现"><span>算子实现</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#算子优化"><span>算子优化</span></a><ul class="menu-list"><li><a class="is-flex is-mobile" href="#算子逻辑优化"><span>算子逻辑优化</span></a></li><li><a class="is-flex is-mobile" href="#分核方案优化"><span>分核方案优化</span></a></li></ul></li><li><a class="is-flex is-mobile" href="#功能测试"><span>功能测试</span></a></li><li><a class="is-flex is-mobile" href="#性能测试"><span>性能测试</span></a></li></ul></div></div><style>.menu-list > li > a.is-active + .menu-list { display: block; }.menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="https://user-images.githubusercontent.com/56388518/193990104-d040c2b4-1b96-4636-b410-b2ccd6360665.jpg" alt="亦初"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">亦初</p><p class="is-size-6 is-block">落霞与孤鹜齐飞，秋水共长天一色</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>冰岛</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">75</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">23</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">76</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/Deleter-D" target="_blank" rel="noopener">关注我</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/Deleter-D"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Email" href="mailto:18735855248@163.com"><i class="fa fa-envelope"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Telegram" href="https://t.me/GoldPancake687"><i class="fab fa-telegram"></i></a></div><div><hr><p id="hitokoto">:D 一言句子获取中...</p><script type="text/javascript" defer>function getYiyan(){
                                $.getJSON("https://v1.hitokoto.cn/", function (data) {
                                if(data){
                                    $('#hitokoto').html("");
                                    $('#hitokoto').append("<strong style='color: #3273dc;'>"+data.hitokoto+"</strong>"+
                                    "<p>"+"来源《"+data.from+"》</p><p>提供者-"+data.creator+"</p>");
                                }});}
                                $(function (){getYiyan();$('#hitokoto').click(function(){getYiyan();})});</script></div></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新评论</h3><span class="body_hot_comment">加载中，最新评论有1分钟缓存...</span></div></div><div class="card widget"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-03-25T02:07:10.000Z">2024-03-25</time></p><p class="title"><a href="/posts/43333/">深度学习框架机制及分布式并行</a></p><p class="categories"><a href="/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/">高性能计算</a> / <a href="/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/AI%E7%B3%BB%E7%BB%9F/">AI系统</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-20T08:49:53.000Z">2024-02-20</time></p><p class="title"><a href="/posts/9782/">CUDA编程——GPU加速库和OpenACC</a></p><p class="categories"><a href="/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/">高性能计算</a> / <a href="/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/CUDA/">CUDA</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-20T08:45:21.000Z">2024-02-20</time></p><p class="title"><a href="/posts/53610/">CUDA编程——调整指令集原语</a></p><p class="categories"><a href="/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/">高性能计算</a> / <a href="/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/CUDA/">CUDA</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-20T08:36:28.000Z">2024-02-20</time></p><p class="title"><a href="/posts/4919/">CUDA编程——流和并发</a></p><p class="categories"><a href="/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/">高性能计算</a> / <a href="/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/CUDA/">CUDA</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2024-02-20T08:29:56.000Z">2024-02-20</time></p><p class="title"><a href="/posts/50255/">CUDA编程——性能分析工具</a></p><p class="categories"><a href="/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/">高性能计算</a> / <a href="/categories/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/CUDA/">CUDA</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Hexo/"><span class="level-start"><span class="level-item">Hexo</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Linux/"><span class="level-start"><span class="level-item">Linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%89%8D%E7%AB%AF/"><span class="level-start"><span class="level-item">前端</span></span><span class="level-end"><span class="level-item tag">15</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E5%89%8D%E7%AB%AF/Vue/"><span class="level-start"><span class="level-item">Vue</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%89%8D%E7%AB%AF/axios/"><span class="level-start"><span class="level-item">axios</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%89%8D%E7%AB%AF/nodejs/"><span class="level-start"><span class="level-item">nodejs</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%8A%98%E8%85%BE/"><span class="level-start"><span class="level-item">折腾</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E5%AD%A6/"><span class="level-start"><span class="level-item">数学</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E5%AD%A6/%E7%9F%A9%E9%98%B5%E8%AE%BA/"><span class="level-start"><span class="level-item">矩阵论</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li></ul></li><a class="level is-mobile is-marginless" href="/categories/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2024/03/"><span class="level-start"><span class="level-item">三月 2024</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2024/02/"><span class="level-start"><span class="level-item">二月 2024</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/12/"><span class="level-start"><span class="level-item">十二月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/11/"><span class="level-start"><span class="level-item">十一月 2023</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2023/10/"><span class="level-start"><span class="level-item">十月 2023</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><a class="level is-mobile is-marginless" href="/archives/"><span class="level-start"><span class="level-item">查看全部&gt;&gt;</span></span></a></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">标签</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag is-grey-lightest">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%82%E6%9E%84%E8%AE%A1%E7%AE%97/"><span class="tag">异构计算</span><span class="tag is-grey-lightest">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CUDA/"><span class="tag">CUDA</span><span class="tag is-grey-lightest">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"><span class="tag">机器学习</span><span class="tag is-grey-lightest">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AF%95%E6%98%87%E7%BC%96%E8%AF%91%E5%99%A8/"><span class="tag">毕昇编译器</span><span class="tag is-grey-lightest">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97/"><span class="tag">高性能计算</span><span class="tag is-grey-lightest">9</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Vue/"><span class="tag">Vue</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%9B%E6%89%A3/"><span class="tag">力扣</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6/"><span class="tag">数学</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%9F%A9%E9%98%B5%E8%AE%BA/"><span class="tag">矩阵论</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/axios/"><span class="tag">axios</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%82%E6%9E%84%E7%BC%96%E7%A8%8B/"><span class="tag">异构编程</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/3D%E4%BA%BA%E4%BD%93%E5%A7%BF%E6%80%81%E4%BC%B0%E8%AE%A1/"><span class="tag">3D人体姿态估计</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Pytorch/"><span class="tag">Pytorch</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BA%E6%96%87/"><span class="tag">论文</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ITK/"><span class="tag">ITK</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"><span class="tag">深度学习</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/CVPR/"><span class="tag">CVPR</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Hexo/"><span class="tag">Hexo</span><span class="tag is-grey-lightest">2</span></a></div></div><div class="field is-grouped is-grouped-multiline"><a class="tags has-addons" href="/tags/"><span class="tag">查看全部&gt;&gt;</span></a></div></div></div></div><div class="card widget" data-type="links"><div class="card-content"><div class="menu"><h3 class="menu-label">链接</h3><ul class="menu-list"><li><a class="level is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile" href="https://bulma.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">bulma.io</span></span></a></li></ul></div></div></div><div class="card widget" data-type="subscribe-email"><div class="card-content"><div class="menu"><h3 class="menu-label">订阅更新</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button" type="submit" value="订阅"></div></div></form></div></div></div><!--!--><div class="column-right-shadow is-hidden-widescreen"></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="https://user-images.githubusercontent.com/56388518/193990104-d040c2b4-1b96-4636-b410-b2ccd6360665.jpg" alt="亦初" height="28"></a><p class="size-small"><span>&copy; 2024 亦初</span>  Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank">Icarus</a> &amp; <a href="https://github.com/removeif/hexo-theme-amazing" target="_blank">Amazing</a> <br><span>© 版权说明：[本网站所有内容均收集于互联网或自己创作，如有侵权，请<a href="/message" target="_blank">留言</a>，笔者会立即处理]<br /></span><span><span id="statistic-times">loading...</span><script>function createTime(time) {
            var n = new Date(time);
            now.setTime(now.getTime() + 250),
                days = (now - n) / 1e3 / 60 / 60 / 24,
                dnum = Math.floor(days),
                hours = (now - n) / 1e3 / 60 / 60 - 24 * dnum,
                hnum = Math.floor(hours),
            1 == String(hnum).length && (hnum = "0" + hnum),
                minutes = (now - n) / 1e3 / 60 - 1440 * dnum - 60 * hnum,
                mnum = Math.floor(minutes),
            1 == String(mnum).length && (mnum = "0" + mnum),
                seconds = (now - n) / 1e3 - 86400 * dnum - 3600 * hnum - 60 * mnum,
                snum = Math.round(seconds),
            1 == String(snum).length && (snum = "0" + snum),
                document.getElementById("statistic-times").innerHTML = "❤️本站自 <strong>"+time.split(" ")[0].replace(/\//g,".")+"</strong> 已运行 <strong>" + dnum + "</strong> 天 <strong>" + hnum + "</strong> 小时 <strong>" + mnum + "</strong> 分 <strong>" + snum + "</strong> 秒！❤️";
        }var now = new Date();setInterval("createTime('2022/03/13 00:00:00')", 250,"");</script><br></span><div class="size-small"><span>❤️感谢 <strong><span id="busuanzi_value_site_uv">99+</span></strong> 小伙伴的 <strong><span id="busuanzi_value_site_pv">99+</span></strong> 次光临！❤️</span></div></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div><div class="sideMusic"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css"><script src="/js/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script><meting-js style="width: auto;height: 2000px;" server="netease" type="playlist" id="475747480" theme="#2980b9" loop="all" autoplay="false" order="list" storageName="aplayer-setting" lrctype="0" list-max-height="400px" fixed="true"></meting-js></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdnjs.loli.net/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><script>$.getScript('/js/comment-issue-data.js',function(){loadIssueData('d087baa8a532e3b31fba','faec4c1d7046247c200bca62c9930d0799ce58a5','Deleter-D','Deleter-D.github.io',false);})</script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script><script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script><script type="text/javascript">var pjax = new Pjax({
            elements: "a",//代表点击链接就更新
            selectors: [  //代表要更新的节点
                ".section",
                "title"
            ],
            cache: true,
            cacheBust:false
        })

        function loadBusuanzi(){
        $.getScript("//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js", function () {});
        }

        function loadMathJax() { //加载mathjax
            $.getScript("//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/MathJax.js?config=TeX-MML-AM_CHTML", function () {
                MathJax.Hub.Config({ tex2jax: { inlineMath: [['$', '$'], ['\(', '\)']] } });
                var math = document.getElementsByClassName("entry-content")[0];
                MathJax.Hub.Queue(["Typeset", MathJax.Hub, math]);
            });
        };

        // 开始 PJAX 执行的函数
        document.addEventListener('pjax:send', function () {
        });
        
        // PJAX 完成之后执行的函数，可以和上面的重载放在一起
        document.addEventListener('pjax:complete', function () {
            $(".section").css({opacity:1});
            if(true){
                $.getScript('/js/comment-issue-data.js',function(){loadIssueData('d087baa8a532e3b31fba','faec4c1d7046247c200bca62c9930d0799ce58a5','Deleter-D','Deleter-D.github.io',false);});
            }
            if(false){
                loadMathJax();
            }
            loadMainJs(jQuery, window.moment, window.ClipboardJS, window.IcarusThemeSettings);
            loadBackTop();
            loadBusuanzi();
            if(typeof loadBanner == 'function'){
                loadBanner();
            }
        });</script></body></html>